/* soapC.cpp
   Generated by gSOAP 2.7.12 from webserver.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.12 2009-01-21 13:05:28 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_in_LONG64(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_ArrayOfDeviceStatesEx:
		return soap_in_ArrayOfDeviceStatesEx(soap, NULL, NULL, "ns1:DeviceStateEx");
	case SOAP_TYPE_ns1__DeviceStateEx:
		return soap_in_ns1__DeviceStateEx(soap, NULL, NULL, "ns1:DeviceStateEx");
	case SOAP_TYPE_ArrayOfAnyType:
		return soap_in_ArrayOfAnyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_ArrayOfString:
		return soap_in_ArrayOfString(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ArrayOfDeviceStateVariable:
		return soap_in_ArrayOfDeviceStateVariable(soap, NULL, NULL, "ns1:DeviceStateVariable");
	case SOAP_TYPE_ArrayOfMessageEvent:
		return soap_in_ArrayOfMessageEvent(soap, NULL, NULL, "ns1:MessageEvent");
	case SOAP_TYPE_ArrayOfDeviceStates:
		return soap_in_ArrayOfDeviceStates(soap, NULL, NULL, "ns1:DeviceState");
	case SOAP_TYPE_ns1__DeviceStateVariable:
		return soap_in_ns1__DeviceStateVariable(soap, NULL, NULL, "ns1:DeviceStateVariable");
	case SOAP_TYPE_ns1__MessageEvent:
		return soap_in_ns1__MessageEvent(soap, NULL, NULL, "ns1:MessageEvent");
	case SOAP_TYPE_ns1__DeviceState:
		return soap_in_ns1__DeviceState(soap, NULL, NULL, "ns1:DeviceState");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__string:
		return soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_xsd__long:
		return soap_in_xsd__long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_xsd__int:
		return soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_xsd__dateTime:
		return soap_in_xsd__dateTime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_ns1__getDeviceAvailableActions:
		return soap_in_ns1__getDeviceAvailableActions(soap, NULL, NULL, "ns1:getDeviceAvailableActions");
	case SOAP_TYPE_ns1__getDeviceAvailableActionsResponse:
		return soap_in_ns1__getDeviceAvailableActionsResponse(soap, NULL, NULL, "ns1:getDeviceAvailableActionsResponse");
	case SOAP_TYPE_ns1__getDeviceStateVariables:
		return soap_in_ns1__getDeviceStateVariables(soap, NULL, NULL, "ns1:getDeviceStateVariables");
	case SOAP_TYPE_ns1__getDeviceStateVariablesResponse:
		return soap_in_ns1__getDeviceStateVariablesResponse(soap, NULL, NULL, "ns1:getDeviceStateVariablesResponse");
	case SOAP_TYPE_ns1__getLastDevicesEvents:
		return soap_in_ns1__getLastDevicesEvents(soap, NULL, NULL, "ns1:getLastDevicesEvents");
	case SOAP_TYPE_ns1__getLastDevicesEventsResponse:
		return soap_in_ns1__getLastDevicesEventsResponse(soap, NULL, NULL, "ns1:getLastDevicesEventsResponse");
	case SOAP_TYPE_ns1__invokeAction:
		return soap_in_ns1__invokeAction(soap, NULL, NULL, "ns1:invokeAction");
	case SOAP_TYPE_ns1__invokeActionResponse:
		return soap_in_ns1__invokeActionResponse(soap, NULL, NULL, "ns1:invokeActionResponse");
	case SOAP_TYPE_ns1__getAllDevicesOverviewExtendedData:
		return soap_in_ns1__getAllDevicesOverviewExtendedData(soap, NULL, NULL, "ns1:getAllDevicesOverviewExtendedData");
	case SOAP_TYPE_ns1__getAllDevicesOverviewExtendedDataResponse:
		return soap_in_ns1__getAllDevicesOverviewExtendedDataResponse(soap, NULL, NULL, "ns1:getAllDevicesOverviewExtendedDataResponse");
	case SOAP_TYPE_ns1__getAllDevicesOverviewData:
		return soap_in_ns1__getAllDevicesOverviewData(soap, NULL, NULL, "ns1:getAllDevicesOverviewData");
	case SOAP_TYPE_ns1__getAllDevicesOverviewDataResponse:
		return soap_in_ns1__getAllDevicesOverviewDataResponse(soap, NULL, NULL, "ns1:getAllDevicesOverviewDataResponse");
	case SOAP_TYPE_ns1__getDeviceOverviewExtendedData:
		return soap_in_ns1__getDeviceOverviewExtendedData(soap, NULL, NULL, "ns1:getDeviceOverviewExtendedData");
	case SOAP_TYPE_ns1__getDeviceOverviewExtendedDataResponse:
		return soap_in_ns1__getDeviceOverviewExtendedDataResponse(soap, NULL, NULL, "ns1:getDeviceOverviewExtendedDataResponse");
	case SOAP_TYPE_ns1__getDeviceOverviewData:
		return soap_in_ns1__getDeviceOverviewData(soap, NULL, NULL, "ns1:getDeviceOverviewData");
	case SOAP_TYPE_ns1__getDeviceOverviewDataResponse:
		return soap_in_ns1__getDeviceOverviewDataResponse(soap, NULL, NULL, "ns1:getDeviceOverviewDataResponse");
	case SOAP_TYPE_ns1__getAvailableDevicesIDs:
		return soap_in_ns1__getAvailableDevicesIDs(soap, NULL, NULL, "ns1:getAvailableDevicesIDs");
	case SOAP_TYPE_ns1__getAvailableDevicesIDsResponse:
		return soap_in_ns1__getAvailableDevicesIDsResponse(soap, NULL, NULL, "ns1:getAvailableDevicesIDsResponse");
	case SOAP_TYPE_ns1__getServerTimestamp:
		return soap_in_ns1__getServerTimestamp(soap, NULL, NULL, "ns1:getServerTimestamp");
	case SOAP_TYPE_ns1__getServerTimestampResponse:
		return soap_in_ns1__getServerTimestampResponse(soap, NULL, NULL, "ns1:getServerTimestampResponse");
	case SOAP_TYPE_ns1__echo:
		return soap_in_ns1__echo(soap, NULL, NULL, "ns1:echo");
	case SOAP_TYPE_ns1__echoResponse:
		return soap_in_ns1__echoResponse(soap, NULL, NULL, "ns1:echoResponse");
	case SOAP_TYPE_PointerToArrayOfDeviceStateVariable:
		return soap_in_PointerToArrayOfDeviceStateVariable(soap, NULL, NULL, "ns1:DeviceStateVariable");
	case SOAP_TYPE_PointerToArrayOfMessageEvent:
		return soap_in_PointerToArrayOfMessageEvent(soap, NULL, NULL, "ns1:MessageEvent");
	case SOAP_TYPE_PointerToArrayOfAnyType:
		return soap_in_PointerToArrayOfAnyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerToArrayOfDeviceStatesEx:
		return soap_in_PointerToArrayOfDeviceStatesEx(soap, NULL, NULL, "ns1:DeviceStateEx");
	case SOAP_TYPE_PointerToArrayOfDeviceStates:
		return soap_in_PointerToArrayOfDeviceStates(soap, NULL, NULL, "ns1:DeviceState");
	case SOAP_TYPE_PointerToPointerTons1__DeviceStateEx:
		return soap_in_PointerToPointerTons1__DeviceStateEx(soap, NULL, NULL, "ns1:DeviceStateEx");
	case SOAP_TYPE_PointerTons1__DeviceStateEx:
		return soap_in_PointerTons1__DeviceStateEx(soap, NULL, NULL, "ns1:DeviceStateEx");
	case SOAP_TYPE_PointerToPointerToxsd__anyType:
		return soap_in_PointerToPointerToxsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_in_PointerToxsd__anyType(soap, NULL, NULL, "xsd:anyType");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons1__DeviceStateVariable:
		return soap_in_PointerToPointerTons1__DeviceStateVariable(soap, NULL, NULL, "ns1:DeviceStateVariable");
	case SOAP_TYPE_PointerTons1__DeviceStateVariable:
		return soap_in_PointerTons1__DeviceStateVariable(soap, NULL, NULL, "ns1:DeviceStateVariable");
	case SOAP_TYPE_PointerToPointerTons1__MessageEvent:
		return soap_in_PointerToPointerTons1__MessageEvent(soap, NULL, NULL, "ns1:MessageEvent");
	case SOAP_TYPE_PointerTons1__MessageEvent:
		return soap_in_PointerTons1__MessageEvent(soap, NULL, NULL, "ns1:MessageEvent");
	case SOAP_TYPE_PointerToPointerTons1__DeviceState:
		return soap_in_PointerToPointerTons1__DeviceState(soap, NULL, NULL, "ns1:DeviceState");
	case SOAP_TYPE_PointerTons1__DeviceState:
		return soap_in_PointerTons1__DeviceState(soap, NULL, NULL, "ns1:DeviceState");
	case SOAP_TYPE_PointerToArrayOfString:
		return soap_in_PointerToArrayOfString(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (*soap->arrayType && !soap_match_array(soap, "ns1:DeviceStateEx"))
		{	*type = SOAP_TYPE_ArrayOfDeviceStatesEx;
			return soap_in_ArrayOfDeviceStatesEx(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeviceStateEx"))
		{	*type = SOAP_TYPE_ns1__DeviceStateEx;
			return soap_in_ns1__DeviceStateEx(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:anyType"))
		{	*type = SOAP_TYPE_ArrayOfAnyType;
			return soap_in_ArrayOfAnyType(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "xsd:string"))
		{	*type = SOAP_TYPE_ArrayOfString;
			return soap_in_ArrayOfString(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:DeviceStateVariable"))
		{	*type = SOAP_TYPE_ArrayOfDeviceStateVariable;
			return soap_in_ArrayOfDeviceStateVariable(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:MessageEvent"))
		{	*type = SOAP_TYPE_ArrayOfMessageEvent;
			return soap_in_ArrayOfMessageEvent(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:DeviceState"))
		{	*type = SOAP_TYPE_ArrayOfDeviceStates;
			return soap_in_ArrayOfDeviceStates(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeviceStateVariable"))
		{	*type = SOAP_TYPE_ns1__DeviceStateVariable;
			return soap_in_ns1__DeviceStateVariable(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MessageEvent"))
		{	*type = SOAP_TYPE_ns1__MessageEvent;
			return soap_in_ns1__MessageEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeviceState"))
		{	*type = SOAP_TYPE_ns1__DeviceState;
			return soap_in_ns1__DeviceState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_xsd__string;
			return soap_in_xsd__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_xsd__long;
			return soap_in_xsd__long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_xsd__int;
			return soap_in_xsd__int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_xsd__dateTime;
			return soap_in_xsd__dateTime(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_LONG64;
			return soap_in_LONG64(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDeviceAvailableActions"))
		{	*type = SOAP_TYPE_ns1__getDeviceAvailableActions;
			return soap_in_ns1__getDeviceAvailableActions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDeviceAvailableActionsResponse"))
		{	*type = SOAP_TYPE_ns1__getDeviceAvailableActionsResponse;
			return soap_in_ns1__getDeviceAvailableActionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDeviceStateVariables"))
		{	*type = SOAP_TYPE_ns1__getDeviceStateVariables;
			return soap_in_ns1__getDeviceStateVariables(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDeviceStateVariablesResponse"))
		{	*type = SOAP_TYPE_ns1__getDeviceStateVariablesResponse;
			return soap_in_ns1__getDeviceStateVariablesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLastDevicesEvents"))
		{	*type = SOAP_TYPE_ns1__getLastDevicesEvents;
			return soap_in_ns1__getLastDevicesEvents(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getLastDevicesEventsResponse"))
		{	*type = SOAP_TYPE_ns1__getLastDevicesEventsResponse;
			return soap_in_ns1__getLastDevicesEventsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:invokeAction"))
		{	*type = SOAP_TYPE_ns1__invokeAction;
			return soap_in_ns1__invokeAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:invokeActionResponse"))
		{	*type = SOAP_TYPE_ns1__invokeActionResponse;
			return soap_in_ns1__invokeActionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllDevicesOverviewExtendedData"))
		{	*type = SOAP_TYPE_ns1__getAllDevicesOverviewExtendedData;
			return soap_in_ns1__getAllDevicesOverviewExtendedData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllDevicesOverviewExtendedDataResponse"))
		{	*type = SOAP_TYPE_ns1__getAllDevicesOverviewExtendedDataResponse;
			return soap_in_ns1__getAllDevicesOverviewExtendedDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllDevicesOverviewData"))
		{	*type = SOAP_TYPE_ns1__getAllDevicesOverviewData;
			return soap_in_ns1__getAllDevicesOverviewData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAllDevicesOverviewDataResponse"))
		{	*type = SOAP_TYPE_ns1__getAllDevicesOverviewDataResponse;
			return soap_in_ns1__getAllDevicesOverviewDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDeviceOverviewExtendedData"))
		{	*type = SOAP_TYPE_ns1__getDeviceOverviewExtendedData;
			return soap_in_ns1__getDeviceOverviewExtendedData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDeviceOverviewExtendedDataResponse"))
		{	*type = SOAP_TYPE_ns1__getDeviceOverviewExtendedDataResponse;
			return soap_in_ns1__getDeviceOverviewExtendedDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDeviceOverviewData"))
		{	*type = SOAP_TYPE_ns1__getDeviceOverviewData;
			return soap_in_ns1__getDeviceOverviewData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getDeviceOverviewDataResponse"))
		{	*type = SOAP_TYPE_ns1__getDeviceOverviewDataResponse;
			return soap_in_ns1__getDeviceOverviewDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAvailableDevicesIDs"))
		{	*type = SOAP_TYPE_ns1__getAvailableDevicesIDs;
			return soap_in_ns1__getAvailableDevicesIDs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getAvailableDevicesIDsResponse"))
		{	*type = SOAP_TYPE_ns1__getAvailableDevicesIDsResponse;
			return soap_in_ns1__getAvailableDevicesIDsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getServerTimestamp"))
		{	*type = SOAP_TYPE_ns1__getServerTimestamp;
			return soap_in_ns1__getServerTimestamp(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getServerTimestampResponse"))
		{	*type = SOAP_TYPE_ns1__getServerTimestampResponse;
			return soap_in_ns1__getServerTimestampResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:echo"))
		{	*type = SOAP_TYPE_ns1__echo;
			return soap_in_ns1__echo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:echoResponse"))
		{	*type = SOAP_TYPE_ns1__echoResponse;
			return soap_in_ns1__echoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_LONG64:
		return soap_out_LONG64(soap, tag, id, (const LONG64 *)ptr, "xsd:long");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_ArrayOfDeviceStatesEx:
		return ((ArrayOfDeviceStatesEx *)ptr)->soap_out(soap, tag, id, "ns1:DeviceStateEx");
	case SOAP_TYPE_ns1__DeviceStateEx:
		return ((ns1__DeviceStateEx *)ptr)->soap_out(soap, tag, id, "ns1:DeviceStateEx");
	case SOAP_TYPE_ArrayOfAnyType:
		return ((ArrayOfAnyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
	case SOAP_TYPE_ArrayOfString:
		return ((ArrayOfString *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_ArrayOfDeviceStateVariable:
		return ((ArrayOfDeviceStateVariable *)ptr)->soap_out(soap, tag, id, "ns1:DeviceStateVariable");
	case SOAP_TYPE_ArrayOfMessageEvent:
		return ((ArrayOfMessageEvent *)ptr)->soap_out(soap, tag, id, "ns1:MessageEvent");
	case SOAP_TYPE_ArrayOfDeviceStates:
		return ((ArrayOfDeviceStates *)ptr)->soap_out(soap, tag, id, "ns1:DeviceState");
	case SOAP_TYPE_ns1__DeviceStateVariable:
		return ((ns1__DeviceStateVariable *)ptr)->soap_out(soap, tag, id, "ns1:DeviceStateVariable");
	case SOAP_TYPE_ns1__MessageEvent:
		return ((ns1__MessageEvent *)ptr)->soap_out(soap, tag, id, "ns1:MessageEvent");
	case SOAP_TYPE_ns1__DeviceState:
		return ((ns1__DeviceState *)ptr)->soap_out(soap, tag, id, "ns1:DeviceState");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_xsd__string:
		return ((xsd__string *)ptr)->soap_out(soap, tag, id, "xsd:string");
	case SOAP_TYPE_xsd__long:
		return ((xsd__long *)ptr)->soap_out(soap, tag, id, "xsd:long");
	case SOAP_TYPE_xsd__int:
		return ((xsd__int *)ptr)->soap_out(soap, tag, id, "xsd:int");
	case SOAP_TYPE_xsd__dateTime:
		return ((xsd__dateTime *)ptr)->soap_out(soap, tag, id, "xsd:dateTime");
	case SOAP_TYPE_xsd__anyType:
		return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
	case SOAP_TYPE_ns1__getDeviceAvailableActions:
		return soap_out_ns1__getDeviceAvailableActions(soap, tag, id, (const struct ns1__getDeviceAvailableActions *)ptr, "ns1:getDeviceAvailableActions");
	case SOAP_TYPE_ns1__getDeviceAvailableActionsResponse:
		return soap_out_ns1__getDeviceAvailableActionsResponse(soap, tag, id, (const struct ns1__getDeviceAvailableActionsResponse *)ptr, "ns1:getDeviceAvailableActionsResponse");
	case SOAP_TYPE_ns1__getDeviceStateVariables:
		return soap_out_ns1__getDeviceStateVariables(soap, tag, id, (const struct ns1__getDeviceStateVariables *)ptr, "ns1:getDeviceStateVariables");
	case SOAP_TYPE_ns1__getDeviceStateVariablesResponse:
		return soap_out_ns1__getDeviceStateVariablesResponse(soap, tag, id, (const struct ns1__getDeviceStateVariablesResponse *)ptr, "ns1:getDeviceStateVariablesResponse");
	case SOAP_TYPE_ns1__getLastDevicesEvents:
		return soap_out_ns1__getLastDevicesEvents(soap, tag, id, (const struct ns1__getLastDevicesEvents *)ptr, "ns1:getLastDevicesEvents");
	case SOAP_TYPE_ns1__getLastDevicesEventsResponse:
		return soap_out_ns1__getLastDevicesEventsResponse(soap, tag, id, (const struct ns1__getLastDevicesEventsResponse *)ptr, "ns1:getLastDevicesEventsResponse");
	case SOAP_TYPE_ns1__invokeAction:
		return soap_out_ns1__invokeAction(soap, tag, id, (const struct ns1__invokeAction *)ptr, "ns1:invokeAction");
	case SOAP_TYPE_ns1__invokeActionResponse:
		return soap_out_ns1__invokeActionResponse(soap, tag, id, (const struct ns1__invokeActionResponse *)ptr, "ns1:invokeActionResponse");
	case SOAP_TYPE_ns1__getAllDevicesOverviewExtendedData:
		return soap_out_ns1__getAllDevicesOverviewExtendedData(soap, tag, id, (const struct ns1__getAllDevicesOverviewExtendedData *)ptr, "ns1:getAllDevicesOverviewExtendedData");
	case SOAP_TYPE_ns1__getAllDevicesOverviewExtendedDataResponse:
		return soap_out_ns1__getAllDevicesOverviewExtendedDataResponse(soap, tag, id, (const struct ns1__getAllDevicesOverviewExtendedDataResponse *)ptr, "ns1:getAllDevicesOverviewExtendedDataResponse");
	case SOAP_TYPE_ns1__getAllDevicesOverviewData:
		return soap_out_ns1__getAllDevicesOverviewData(soap, tag, id, (const struct ns1__getAllDevicesOverviewData *)ptr, "ns1:getAllDevicesOverviewData");
	case SOAP_TYPE_ns1__getAllDevicesOverviewDataResponse:
		return soap_out_ns1__getAllDevicesOverviewDataResponse(soap, tag, id, (const struct ns1__getAllDevicesOverviewDataResponse *)ptr, "ns1:getAllDevicesOverviewDataResponse");
	case SOAP_TYPE_ns1__getDeviceOverviewExtendedData:
		return soap_out_ns1__getDeviceOverviewExtendedData(soap, tag, id, (const struct ns1__getDeviceOverviewExtendedData *)ptr, "ns1:getDeviceOverviewExtendedData");
	case SOAP_TYPE_ns1__getDeviceOverviewExtendedDataResponse:
		return soap_out_ns1__getDeviceOverviewExtendedDataResponse(soap, tag, id, (const struct ns1__getDeviceOverviewExtendedDataResponse *)ptr, "ns1:getDeviceOverviewExtendedDataResponse");
	case SOAP_TYPE_ns1__getDeviceOverviewData:
		return soap_out_ns1__getDeviceOverviewData(soap, tag, id, (const struct ns1__getDeviceOverviewData *)ptr, "ns1:getDeviceOverviewData");
	case SOAP_TYPE_ns1__getDeviceOverviewDataResponse:
		return soap_out_ns1__getDeviceOverviewDataResponse(soap, tag, id, (const struct ns1__getDeviceOverviewDataResponse *)ptr, "ns1:getDeviceOverviewDataResponse");
	case SOAP_TYPE_ns1__getAvailableDevicesIDs:
		return soap_out_ns1__getAvailableDevicesIDs(soap, tag, id, (const struct ns1__getAvailableDevicesIDs *)ptr, "ns1:getAvailableDevicesIDs");
	case SOAP_TYPE_ns1__getAvailableDevicesIDsResponse:
		return soap_out_ns1__getAvailableDevicesIDsResponse(soap, tag, id, (const struct ns1__getAvailableDevicesIDsResponse *)ptr, "ns1:getAvailableDevicesIDsResponse");
	case SOAP_TYPE_ns1__getServerTimestamp:
		return soap_out_ns1__getServerTimestamp(soap, tag, id, (const struct ns1__getServerTimestamp *)ptr, "ns1:getServerTimestamp");
	case SOAP_TYPE_ns1__getServerTimestampResponse:
		return soap_out_ns1__getServerTimestampResponse(soap, tag, id, (const struct ns1__getServerTimestampResponse *)ptr, "ns1:getServerTimestampResponse");
	case SOAP_TYPE_ns1__echo:
		return soap_out_ns1__echo(soap, tag, id, (const struct ns1__echo *)ptr, "ns1:echo");
	case SOAP_TYPE_ns1__echoResponse:
		return soap_out_ns1__echoResponse(soap, tag, id, (const struct ns1__echoResponse *)ptr, "ns1:echoResponse");
	case SOAP_TYPE_PointerToArrayOfDeviceStateVariable:
		return soap_out_PointerToArrayOfDeviceStateVariable(soap, tag, id, (ArrayOfDeviceStateVariable *const*)ptr, "ns1:DeviceStateVariable");
	case SOAP_TYPE_PointerToArrayOfMessageEvent:
		return soap_out_PointerToArrayOfMessageEvent(soap, tag, id, (ArrayOfMessageEvent *const*)ptr, "ns1:MessageEvent");
	case SOAP_TYPE_PointerToArrayOfAnyType:
		return soap_out_PointerToArrayOfAnyType(soap, tag, id, (ArrayOfAnyType *const*)ptr, "xsd:anyType");
	case SOAP_TYPE_PointerToArrayOfDeviceStatesEx:
		return soap_out_PointerToArrayOfDeviceStatesEx(soap, tag, id, (ArrayOfDeviceStatesEx *const*)ptr, "ns1:DeviceStateEx");
	case SOAP_TYPE_PointerToArrayOfDeviceStates:
		return soap_out_PointerToArrayOfDeviceStates(soap, tag, id, (ArrayOfDeviceStates *const*)ptr, "ns1:DeviceState");
	case SOAP_TYPE_PointerToPointerTons1__DeviceStateEx:
		return soap_out_PointerToPointerTons1__DeviceStateEx(soap, tag, id, (ns1__DeviceStateEx **const*)ptr, "ns1:DeviceStateEx");
	case SOAP_TYPE_PointerTons1__DeviceStateEx:
		return soap_out_PointerTons1__DeviceStateEx(soap, tag, id, (ns1__DeviceStateEx *const*)ptr, "ns1:DeviceStateEx");
	case SOAP_TYPE_PointerToPointerToxsd__anyType:
		return soap_out_PointerToPointerToxsd__anyType(soap, tag, id, (xsd__anyType **const*)ptr, "xsd:anyType");
	case SOAP_TYPE_PointerToxsd__anyType:
		return soap_out_PointerToxsd__anyType(soap, tag, id, (xsd__anyType *const*)ptr, "xsd:anyType");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerToPointerTons1__DeviceStateVariable:
		return soap_out_PointerToPointerTons1__DeviceStateVariable(soap, tag, id, (ns1__DeviceStateVariable **const*)ptr, "ns1:DeviceStateVariable");
	case SOAP_TYPE_PointerTons1__DeviceStateVariable:
		return soap_out_PointerTons1__DeviceStateVariable(soap, tag, id, (ns1__DeviceStateVariable *const*)ptr, "ns1:DeviceStateVariable");
	case SOAP_TYPE_PointerToPointerTons1__MessageEvent:
		return soap_out_PointerToPointerTons1__MessageEvent(soap, tag, id, (ns1__MessageEvent **const*)ptr, "ns1:MessageEvent");
	case SOAP_TYPE_PointerTons1__MessageEvent:
		return soap_out_PointerTons1__MessageEvent(soap, tag, id, (ns1__MessageEvent *const*)ptr, "ns1:MessageEvent");
	case SOAP_TYPE_PointerToPointerTons1__DeviceState:
		return soap_out_PointerToPointerTons1__DeviceState(soap, tag, id, (ns1__DeviceState **const*)ptr, "ns1:DeviceState");
	case SOAP_TYPE_PointerTons1__DeviceState:
		return soap_out_PointerTons1__DeviceState(soap, tag, id, (ns1__DeviceState *const*)ptr, "ns1:DeviceState");
	case SOAP_TYPE_PointerToArrayOfString:
		return soap_out_PointerToArrayOfString(soap, tag, id, (ArrayOfString *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ArrayOfDeviceStatesEx:
		((ArrayOfDeviceStatesEx *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DeviceStateEx:
		((ns1__DeviceStateEx *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfAnyType:
		((ArrayOfAnyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfString:
		((ArrayOfString *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfDeviceStateVariable:
		((ArrayOfDeviceStateVariable *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfMessageEvent:
		((ArrayOfMessageEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfDeviceStates:
		((ArrayOfDeviceStates *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DeviceStateVariable:
		((ns1__DeviceStateVariable *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MessageEvent:
		((ns1__MessageEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__DeviceState:
		((ns1__DeviceState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__string:
		((xsd__string *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__long:
		((xsd__long *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__int:
		((xsd__int *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__dateTime:
		((xsd__dateTime *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__anyType:
		((xsd__anyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getDeviceAvailableActions:
		soap_serialize_ns1__getDeviceAvailableActions(soap, (const struct ns1__getDeviceAvailableActions *)ptr);
		break;
	case SOAP_TYPE_ns1__getDeviceAvailableActionsResponse:
		soap_serialize_ns1__getDeviceAvailableActionsResponse(soap, (const struct ns1__getDeviceAvailableActionsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getDeviceStateVariables:
		soap_serialize_ns1__getDeviceStateVariables(soap, (const struct ns1__getDeviceStateVariables *)ptr);
		break;
	case SOAP_TYPE_ns1__getDeviceStateVariablesResponse:
		soap_serialize_ns1__getDeviceStateVariablesResponse(soap, (const struct ns1__getDeviceStateVariablesResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getLastDevicesEvents:
		soap_serialize_ns1__getLastDevicesEvents(soap, (const struct ns1__getLastDevicesEvents *)ptr);
		break;
	case SOAP_TYPE_ns1__getLastDevicesEventsResponse:
		soap_serialize_ns1__getLastDevicesEventsResponse(soap, (const struct ns1__getLastDevicesEventsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__invokeAction:
		soap_serialize_ns1__invokeAction(soap, (const struct ns1__invokeAction *)ptr);
		break;
	case SOAP_TYPE_ns1__invokeActionResponse:
		soap_serialize_ns1__invokeActionResponse(soap, (const struct ns1__invokeActionResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getAllDevicesOverviewExtendedData:
		soap_serialize_ns1__getAllDevicesOverviewExtendedData(soap, (const struct ns1__getAllDevicesOverviewExtendedData *)ptr);
		break;
	case SOAP_TYPE_ns1__getAllDevicesOverviewExtendedDataResponse:
		soap_serialize_ns1__getAllDevicesOverviewExtendedDataResponse(soap, (const struct ns1__getAllDevicesOverviewExtendedDataResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getAllDevicesOverviewData:
		soap_serialize_ns1__getAllDevicesOverviewData(soap, (const struct ns1__getAllDevicesOverviewData *)ptr);
		break;
	case SOAP_TYPE_ns1__getAllDevicesOverviewDataResponse:
		soap_serialize_ns1__getAllDevicesOverviewDataResponse(soap, (const struct ns1__getAllDevicesOverviewDataResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getDeviceOverviewExtendedData:
		soap_serialize_ns1__getDeviceOverviewExtendedData(soap, (const struct ns1__getDeviceOverviewExtendedData *)ptr);
		break;
	case SOAP_TYPE_ns1__getDeviceOverviewExtendedDataResponse:
		soap_serialize_ns1__getDeviceOverviewExtendedDataResponse(soap, (const struct ns1__getDeviceOverviewExtendedDataResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getDeviceOverviewData:
		soap_serialize_ns1__getDeviceOverviewData(soap, (const struct ns1__getDeviceOverviewData *)ptr);
		break;
	case SOAP_TYPE_ns1__getDeviceOverviewDataResponse:
		soap_serialize_ns1__getDeviceOverviewDataResponse(soap, (const struct ns1__getDeviceOverviewDataResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getAvailableDevicesIDs:
		soap_serialize_ns1__getAvailableDevicesIDs(soap, (const struct ns1__getAvailableDevicesIDs *)ptr);
		break;
	case SOAP_TYPE_ns1__getAvailableDevicesIDsResponse:
		soap_serialize_ns1__getAvailableDevicesIDsResponse(soap, (const struct ns1__getAvailableDevicesIDsResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__getServerTimestamp:
		soap_serialize_ns1__getServerTimestamp(soap, (const struct ns1__getServerTimestamp *)ptr);
		break;
	case SOAP_TYPE_ns1__getServerTimestampResponse:
		soap_serialize_ns1__getServerTimestampResponse(soap, (const struct ns1__getServerTimestampResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__echo:
		soap_serialize_ns1__echo(soap, (const struct ns1__echo *)ptr);
		break;
	case SOAP_TYPE_ns1__echoResponse:
		soap_serialize_ns1__echoResponse(soap, (const struct ns1__echoResponse *)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfDeviceStateVariable:
		soap_serialize_PointerToArrayOfDeviceStateVariable(soap, (ArrayOfDeviceStateVariable *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfMessageEvent:
		soap_serialize_PointerToArrayOfMessageEvent(soap, (ArrayOfMessageEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfAnyType:
		soap_serialize_PointerToArrayOfAnyType(soap, (ArrayOfAnyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfDeviceStatesEx:
		soap_serialize_PointerToArrayOfDeviceStatesEx(soap, (ArrayOfDeviceStatesEx *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfDeviceStates:
		soap_serialize_PointerToArrayOfDeviceStates(soap, (ArrayOfDeviceStates *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__DeviceStateEx:
		soap_serialize_PointerToPointerTons1__DeviceStateEx(soap, (ns1__DeviceStateEx **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DeviceStateEx:
		soap_serialize_PointerTons1__DeviceStateEx(soap, (ns1__DeviceStateEx *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerToxsd__anyType:
		soap_serialize_PointerToPointerToxsd__anyType(soap, (xsd__anyType **const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyType:
		soap_serialize_PointerToxsd__anyType(soap, (xsd__anyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__DeviceStateVariable:
		soap_serialize_PointerToPointerTons1__DeviceStateVariable(soap, (ns1__DeviceStateVariable **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DeviceStateVariable:
		soap_serialize_PointerTons1__DeviceStateVariable(soap, (ns1__DeviceStateVariable *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__MessageEvent:
		soap_serialize_PointerToPointerTons1__MessageEvent(soap, (ns1__MessageEvent **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MessageEvent:
		soap_serialize_PointerTons1__MessageEvent(soap, (ns1__MessageEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__DeviceState:
		soap_serialize_PointerToPointerTons1__DeviceState(soap, (ns1__DeviceState **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__DeviceState:
		soap_serialize_PointerTons1__DeviceState(soap, (ns1__DeviceState *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfString:
		soap_serialize_PointerToArrayOfString(soap, (ArrayOfString *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__dateTime:
		return (void*)soap_instantiate_xsd__dateTime(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__int:
		return (void*)soap_instantiate_xsd__int(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__long:
		return (void*)soap_instantiate_xsd__long(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__string:
		return (void*)soap_instantiate_xsd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeviceState:
		return (void*)soap_instantiate_ns1__DeviceState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MessageEvent:
		return (void*)soap_instantiate_ns1__MessageEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeviceStateVariable:
		return (void*)soap_instantiate_ns1__DeviceStateVariable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__DeviceStateEx:
		return (void*)soap_instantiate_ns1__DeviceStateEx(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfDeviceStates:
		return (void*)soap_instantiate_ArrayOfDeviceStates(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfMessageEvent:
		return (void*)soap_instantiate_ArrayOfMessageEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfDeviceStateVariable:
		return (void*)soap_instantiate_ArrayOfDeviceStateVariable(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfString:
		return (void*)soap_instantiate_ArrayOfString(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfAnyType:
		return (void*)soap_instantiate_ArrayOfAnyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfDeviceStatesEx:
		return (void*)soap_instantiate_ArrayOfDeviceStatesEx(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__echoResponse:
		return (void*)soap_instantiate_ns1__echoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__echo:
		return (void*)soap_instantiate_ns1__echo(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getServerTimestampResponse:
		return (void*)soap_instantiate_ns1__getServerTimestampResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getServerTimestamp:
		return (void*)soap_instantiate_ns1__getServerTimestamp(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAvailableDevicesIDsResponse:
		return (void*)soap_instantiate_ns1__getAvailableDevicesIDsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAvailableDevicesIDs:
		return (void*)soap_instantiate_ns1__getAvailableDevicesIDs(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDeviceOverviewDataResponse:
		return (void*)soap_instantiate_ns1__getDeviceOverviewDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDeviceOverviewData:
		return (void*)soap_instantiate_ns1__getDeviceOverviewData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDeviceOverviewExtendedDataResponse:
		return (void*)soap_instantiate_ns1__getDeviceOverviewExtendedDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDeviceOverviewExtendedData:
		return (void*)soap_instantiate_ns1__getDeviceOverviewExtendedData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAllDevicesOverviewDataResponse:
		return (void*)soap_instantiate_ns1__getAllDevicesOverviewDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAllDevicesOverviewData:
		return (void*)soap_instantiate_ns1__getAllDevicesOverviewData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAllDevicesOverviewExtendedDataResponse:
		return (void*)soap_instantiate_ns1__getAllDevicesOverviewExtendedDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getAllDevicesOverviewExtendedData:
		return (void*)soap_instantiate_ns1__getAllDevicesOverviewExtendedData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__invokeActionResponse:
		return (void*)soap_instantiate_ns1__invokeActionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__invokeAction:
		return (void*)soap_instantiate_ns1__invokeAction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getLastDevicesEventsResponse:
		return (void*)soap_instantiate_ns1__getLastDevicesEventsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getLastDevicesEvents:
		return (void*)soap_instantiate_ns1__getLastDevicesEvents(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDeviceStateVariablesResponse:
		return (void*)soap_instantiate_ns1__getDeviceStateVariablesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDeviceStateVariables:
		return (void*)soap_instantiate_ns1__getDeviceStateVariables(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDeviceAvailableActionsResponse:
		return (void*)soap_instantiate_ns1__getDeviceAvailableActionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getDeviceAvailableActions:
		return (void*)soap_instantiate_ns1__getDeviceAvailableActions(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			delete (xsd__anyType*)p->ptr;
		else
			delete[] (xsd__anyType*)p->ptr;
		break;
	case SOAP_TYPE_xsd__dateTime:
		if (p->size < 0)
			delete (xsd__dateTime*)p->ptr;
		else
			delete[] (xsd__dateTime*)p->ptr;
		break;
	case SOAP_TYPE_xsd__int:
		if (p->size < 0)
			delete (xsd__int*)p->ptr;
		else
			delete[] (xsd__int*)p->ptr;
		break;
	case SOAP_TYPE_xsd__long:
		if (p->size < 0)
			delete (xsd__long*)p->ptr;
		else
			delete[] (xsd__long*)p->ptr;
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_xsd__string:
		if (p->size < 0)
			delete (xsd__string*)p->ptr;
		else
			delete[] (xsd__string*)p->ptr;
		break;
	case SOAP_TYPE_ns1__DeviceState:
		if (p->size < 0)
			delete (ns1__DeviceState*)p->ptr;
		else
			delete[] (ns1__DeviceState*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MessageEvent:
		if (p->size < 0)
			delete (ns1__MessageEvent*)p->ptr;
		else
			delete[] (ns1__MessageEvent*)p->ptr;
		break;
	case SOAP_TYPE_ns1__DeviceStateVariable:
		if (p->size < 0)
			delete (ns1__DeviceStateVariable*)p->ptr;
		else
			delete[] (ns1__DeviceStateVariable*)p->ptr;
		break;
	case SOAP_TYPE_ns1__DeviceStateEx:
		if (p->size < 0)
			delete (ns1__DeviceStateEx*)p->ptr;
		else
			delete[] (ns1__DeviceStateEx*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfDeviceStates:
		if (p->size < 0)
			delete (ArrayOfDeviceStates*)p->ptr;
		else
			delete[] (ArrayOfDeviceStates*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfMessageEvent:
		if (p->size < 0)
			delete (ArrayOfMessageEvent*)p->ptr;
		else
			delete[] (ArrayOfMessageEvent*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfDeviceStateVariable:
		if (p->size < 0)
			delete (ArrayOfDeviceStateVariable*)p->ptr;
		else
			delete[] (ArrayOfDeviceStateVariable*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfString:
		if (p->size < 0)
			delete (ArrayOfString*)p->ptr;
		else
			delete[] (ArrayOfString*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfAnyType:
		if (p->size < 0)
			delete (ArrayOfAnyType*)p->ptr;
		else
			delete[] (ArrayOfAnyType*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfDeviceStatesEx:
		if (p->size < 0)
			delete (ArrayOfDeviceStatesEx*)p->ptr;
		else
			delete[] (ArrayOfDeviceStatesEx*)p->ptr;
		break;
	case SOAP_TYPE_ns1__echoResponse:
		if (p->size < 0)
			delete (struct ns1__echoResponse*)p->ptr;
		else
			delete[] (struct ns1__echoResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__echo:
		if (p->size < 0)
			delete (struct ns1__echo*)p->ptr;
		else
			delete[] (struct ns1__echo*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getServerTimestampResponse:
		if (p->size < 0)
			delete (struct ns1__getServerTimestampResponse*)p->ptr;
		else
			delete[] (struct ns1__getServerTimestampResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getServerTimestamp:
		if (p->size < 0)
			delete (struct ns1__getServerTimestamp*)p->ptr;
		else
			delete[] (struct ns1__getServerTimestamp*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getAvailableDevicesIDsResponse:
		if (p->size < 0)
			delete (struct ns1__getAvailableDevicesIDsResponse*)p->ptr;
		else
			delete[] (struct ns1__getAvailableDevicesIDsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getAvailableDevicesIDs:
		if (p->size < 0)
			delete (struct ns1__getAvailableDevicesIDs*)p->ptr;
		else
			delete[] (struct ns1__getAvailableDevicesIDs*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getDeviceOverviewDataResponse:
		if (p->size < 0)
			delete (struct ns1__getDeviceOverviewDataResponse*)p->ptr;
		else
			delete[] (struct ns1__getDeviceOverviewDataResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getDeviceOverviewData:
		if (p->size < 0)
			delete (struct ns1__getDeviceOverviewData*)p->ptr;
		else
			delete[] (struct ns1__getDeviceOverviewData*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getDeviceOverviewExtendedDataResponse:
		if (p->size < 0)
			delete (struct ns1__getDeviceOverviewExtendedDataResponse*)p->ptr;
		else
			delete[] (struct ns1__getDeviceOverviewExtendedDataResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getDeviceOverviewExtendedData:
		if (p->size < 0)
			delete (struct ns1__getDeviceOverviewExtendedData*)p->ptr;
		else
			delete[] (struct ns1__getDeviceOverviewExtendedData*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getAllDevicesOverviewDataResponse:
		if (p->size < 0)
			delete (struct ns1__getAllDevicesOverviewDataResponse*)p->ptr;
		else
			delete[] (struct ns1__getAllDevicesOverviewDataResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getAllDevicesOverviewData:
		if (p->size < 0)
			delete (struct ns1__getAllDevicesOverviewData*)p->ptr;
		else
			delete[] (struct ns1__getAllDevicesOverviewData*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getAllDevicesOverviewExtendedDataResponse:
		if (p->size < 0)
			delete (struct ns1__getAllDevicesOverviewExtendedDataResponse*)p->ptr;
		else
			delete[] (struct ns1__getAllDevicesOverviewExtendedDataResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getAllDevicesOverviewExtendedData:
		if (p->size < 0)
			delete (struct ns1__getAllDevicesOverviewExtendedData*)p->ptr;
		else
			delete[] (struct ns1__getAllDevicesOverviewExtendedData*)p->ptr;
		break;
	case SOAP_TYPE_ns1__invokeActionResponse:
		if (p->size < 0)
			delete (struct ns1__invokeActionResponse*)p->ptr;
		else
			delete[] (struct ns1__invokeActionResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__invokeAction:
		if (p->size < 0)
			delete (struct ns1__invokeAction*)p->ptr;
		else
			delete[] (struct ns1__invokeAction*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getLastDevicesEventsResponse:
		if (p->size < 0)
			delete (struct ns1__getLastDevicesEventsResponse*)p->ptr;
		else
			delete[] (struct ns1__getLastDevicesEventsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getLastDevicesEvents:
		if (p->size < 0)
			delete (struct ns1__getLastDevicesEvents*)p->ptr;
		else
			delete[] (struct ns1__getLastDevicesEvents*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getDeviceStateVariablesResponse:
		if (p->size < 0)
			delete (struct ns1__getDeviceStateVariablesResponse*)p->ptr;
		else
			delete[] (struct ns1__getDeviceStateVariablesResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getDeviceStateVariables:
		if (p->size < 0)
			delete (struct ns1__getDeviceStateVariables*)p->ptr;
		else
			delete[] (struct ns1__getDeviceStateVariables*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getDeviceAvailableActionsResponse:
		if (p->size < 0)
			delete (struct ns1__getDeviceAvailableActionsResponse*)p->ptr;
		else
			delete[] (struct ns1__getDeviceAvailableActionsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getDeviceAvailableActions:
		if (p->size < 0)
			delete (struct ns1__getDeviceAvailableActions*)p->ptr;
		else
			delete[] (struct ns1__getDeviceAvailableActions*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{	switch (tt)
	{
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_LONG64(struct soap *soap, LONG64 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_LONG64(struct soap *soap, const LONG64 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_LONG64);
	if (soap_out_LONG64(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 LONG64 * SOAP_FMAC4 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{	LONG64 *p;
	p = soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

void ArrayOfDeviceStatesEx::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfDeviceStatesEx::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfDeviceStatesEx))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__DeviceStateEx(soap, this->__ptr + i);
		}
}

int ArrayOfDeviceStatesEx::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfDeviceStatesEx);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfDeviceStatesEx::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfDeviceStatesEx(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfDeviceStatesEx(struct soap *soap, const char *tag, int id, const ArrayOfDeviceStatesEx *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:DeviceStateEx", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfDeviceStatesEx);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__DeviceStateEx(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfDeviceStatesEx::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfDeviceStatesEx(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfDeviceStatesEx * SOAP_FMAC4 soap_get_ArrayOfDeviceStatesEx(struct soap *soap, ArrayOfDeviceStatesEx *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfDeviceStatesEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ArrayOfDeviceStatesEx::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfDeviceStatesEx(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfDeviceStatesEx * SOAP_FMAC4 soap_in_ArrayOfDeviceStatesEx(struct soap *soap, const char *tag, ArrayOfDeviceStatesEx *a, const char *type)
{	int i, j;
	ns1__DeviceStateEx **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfDeviceStatesEx *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfDeviceStatesEx, sizeof(ArrayOfDeviceStatesEx), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__DeviceStateEx **)soap_malloc(soap, sizeof(ns1__DeviceStateEx *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__DeviceStateEx(soap, NULL, a->__ptr + i, "ns1:DeviceStateEx"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__DeviceStateEx **)soap_push_block(soap, NULL, sizeof(ns1__DeviceStateEx *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__DeviceStateEx(soap, NULL, p, "ns1:DeviceStateEx"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ns1__DeviceStateEx **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfDeviceStatesEx *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfDeviceStatesEx, 0, sizeof(ArrayOfDeviceStatesEx), 0, soap_copy_ArrayOfDeviceStatesEx);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfDeviceStatesEx * SOAP_FMAC6 soap_new_ArrayOfDeviceStatesEx(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfDeviceStatesEx(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfDeviceStatesEx(struct soap *soap, ArrayOfDeviceStatesEx *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfDeviceStatesEx * SOAP_FMAC4 soap_instantiate_ArrayOfDeviceStatesEx(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfDeviceStatesEx(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfDeviceStatesEx, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfDeviceStatesEx;
		if (size)
			*size = sizeof(ArrayOfDeviceStatesEx);
		((ArrayOfDeviceStatesEx*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfDeviceStatesEx[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfDeviceStatesEx);
		for (int i = 0; i < n; i++)
			((ArrayOfDeviceStatesEx*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfDeviceStatesEx*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfDeviceStatesEx(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfDeviceStatesEx %p -> %p\n", q, p));
	*(ArrayOfDeviceStatesEx*)p = *(ArrayOfDeviceStatesEx*)q;
}

void ns1__DeviceStateEx::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__DeviceStateEx::id);
	soap_default_std__string(soap, &this->ns1__DeviceStateEx::name);
	soap_default_std__string(soap, &this->ns1__DeviceStateEx::username);
	soap_default_std__string(soap, &this->ns1__DeviceStateEx::status);
	soap_default_std__string(soap, &this->ns1__DeviceStateEx::text);
	soap_default_int(soap, &this->ns1__DeviceStateEx::state);
	this->ns1__DeviceStateEx::actions = NULL;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__DeviceStateEx::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__DeviceStateEx::id, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DeviceStateEx::id);
	soap_embedded(soap, &this->ns1__DeviceStateEx::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DeviceStateEx::name);
	soap_embedded(soap, &this->ns1__DeviceStateEx::username, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DeviceStateEx::username);
	soap_embedded(soap, &this->ns1__DeviceStateEx::status, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DeviceStateEx::status);
	soap_embedded(soap, &this->ns1__DeviceStateEx::text, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DeviceStateEx::text);
	soap_serialize_PointerToArrayOfString(soap, &this->ns1__DeviceStateEx::actions);
	/* transient soap skipped */
}

int ns1__DeviceStateEx::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__DeviceStateEx);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__DeviceStateEx::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DeviceStateEx(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeviceStateEx(struct soap *soap, const char *tag, int id, const ns1__DeviceStateEx *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeviceStateEx), "ns1:DeviceStateEx"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__string(soap, "id", -1, &(a->ns1__DeviceStateEx::id), ""))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->ns1__DeviceStateEx::name), ""))
		return soap->error;
	if (soap_out_std__string(soap, "username", -1, &(a->ns1__DeviceStateEx::username), ""))
		return soap->error;
	if (soap_out_std__string(soap, "status", -1, &(a->ns1__DeviceStateEx::status), ""))
		return soap->error;
	if (soap_out_std__string(soap, "text", -1, &(a->ns1__DeviceStateEx::text), ""))
		return soap->error;
	if (soap_out_int(soap, "state", -1, &(a->ns1__DeviceStateEx::state), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfString(soap, "actions", -1, &(a->ns1__DeviceStateEx::actions), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DeviceStateEx::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DeviceStateEx(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DeviceStateEx * SOAP_FMAC4 soap_get_ns1__DeviceStateEx(struct soap *soap, ns1__DeviceStateEx *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeviceStateEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__DeviceStateEx::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DeviceStateEx(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DeviceStateEx * SOAP_FMAC4 soap_in_ns1__DeviceStateEx(struct soap *soap, const char *tag, ns1__DeviceStateEx *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DeviceStateEx *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeviceStateEx, sizeof(ns1__DeviceStateEx), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__DeviceStateEx)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__DeviceStateEx *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_username1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_text1 = 1;
	size_t soap_flag_state1 = 1;
	size_t soap_flag_actions1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "id", &(a->ns1__DeviceStateEx::id), "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->ns1__DeviceStateEx::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "username", &(a->ns1__DeviceStateEx::username), "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "status", &(a->ns1__DeviceStateEx::status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "text", &(a->ns1__DeviceStateEx::text), "xsd:string"))
				{	soap_flag_text1--;
					continue;
				}
			if (soap_flag_state1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "state", &(a->ns1__DeviceStateEx::state), "xsd:int"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_actions1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfString(soap, "actions", &(a->ns1__DeviceStateEx::actions), "xsd:string"))
				{	soap_flag_actions1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__DeviceStateEx *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeviceStateEx, 0, sizeof(ns1__DeviceStateEx), 0, soap_copy_ns1__DeviceStateEx);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_name1 > 0 || soap_flag_username1 > 0 || soap_flag_status1 > 0 || soap_flag_text1 > 0 || soap_flag_state1 > 0 || soap_flag_actions1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__DeviceStateEx * SOAP_FMAC6 soap_new_ns1__DeviceStateEx(struct soap *soap, int n)
{	return soap_instantiate_ns1__DeviceStateEx(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__DeviceStateEx(struct soap *soap, ns1__DeviceStateEx *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__DeviceStateEx * SOAP_FMAC4 soap_instantiate_ns1__DeviceStateEx(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeviceStateEx(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DeviceStateEx, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__DeviceStateEx;
		if (size)
			*size = sizeof(ns1__DeviceStateEx);
		((ns1__DeviceStateEx*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__DeviceStateEx[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__DeviceStateEx);
		for (int i = 0; i < n; i++)
			((ns1__DeviceStateEx*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__DeviceStateEx*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DeviceStateEx(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__DeviceStateEx %p -> %p\n", q, p));
	*(ns1__DeviceStateEx*)p = *(ns1__DeviceStateEx*)q;
}

void ArrayOfAnyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfAnyType::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfAnyType))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerToxsd__anyType(soap, this->__ptr + i);
		}
}

int ArrayOfAnyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfAnyType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfAnyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfAnyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfAnyType(struct soap *soap, const char *tag, int id, const ArrayOfAnyType *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "xsd:anyType", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfAnyType);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerToxsd__anyType(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfAnyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfAnyType(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfAnyType * SOAP_FMAC4 soap_get_ArrayOfAnyType(struct soap *soap, ArrayOfAnyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfAnyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ArrayOfAnyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfAnyType(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfAnyType * SOAP_FMAC4 soap_in_ArrayOfAnyType(struct soap *soap, const char *tag, ArrayOfAnyType *a, const char *type)
{	int i, j;
	xsd__anyType **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfAnyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfAnyType, sizeof(ArrayOfAnyType), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (xsd__anyType **)soap_malloc(soap, sizeof(xsd__anyType *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerToxsd__anyType(soap, NULL, a->__ptr + i, "xsd:anyType"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (xsd__anyType **)soap_push_block(soap, NULL, sizeof(xsd__anyType *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerToxsd__anyType(soap, NULL, p, "xsd:anyType"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (xsd__anyType **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfAnyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfAnyType, 0, sizeof(ArrayOfAnyType), 0, soap_copy_ArrayOfAnyType);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfAnyType * SOAP_FMAC6 soap_new_ArrayOfAnyType(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfAnyType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfAnyType(struct soap *soap, ArrayOfAnyType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfAnyType * SOAP_FMAC4 soap_instantiate_ArrayOfAnyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfAnyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfAnyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfAnyType;
		if (size)
			*size = sizeof(ArrayOfAnyType);
		((ArrayOfAnyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfAnyType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfAnyType);
		for (int i = 0; i < n; i++)
			((ArrayOfAnyType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfAnyType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfAnyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfAnyType %p -> %p\n", q, p));
	*(ArrayOfAnyType*)p = *(ArrayOfAnyType*)q;
}

void ArrayOfString::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfString::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfString))
		for (int i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_std__string);
			soap_serialize_std__string(soap, this->__ptr + i);
		}
}

int ArrayOfString::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfString);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfString::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfString(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfString(struct soap *soap, const char *tag, int id, const ArrayOfString *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "xsd:string", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfString);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_std__string(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfString::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfString(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfString * SOAP_FMAC4 soap_get_ArrayOfString(struct soap *soap, ArrayOfString *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ArrayOfString::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfString(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfString * SOAP_FMAC4 soap_in_ArrayOfString(struct soap *soap, const char *tag, ArrayOfString *a, const char *type)
{	int i, j;
	std::string *p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfString *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfString, sizeof(ArrayOfString), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = soap_new_std__string(soap, a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_std__string(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_std__string(soap, NULL, a->__ptr + i, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	std::string q;
			if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (std::string *)soap_push_block(soap, NULL, sizeof(std::string));
				if (!p)
					return NULL;
				memcpy(p, &q, sizeof(std::string));
				soap_default_std__string(soap, p);
				if (!soap_in_std__string(soap, NULL, p, "xsd:string"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			if (soap->blist->size)
				a->__ptr = soap_new_std__string(soap, soap->blist->size/sizeof(std::string));
			else
				a->__ptr = NULL;
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfString *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfString, 0, sizeof(ArrayOfString), 0, soap_copy_ArrayOfString);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfString * SOAP_FMAC6 soap_new_ArrayOfString(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfString(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfString(struct soap *soap, ArrayOfString *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfString * SOAP_FMAC4 soap_instantiate_ArrayOfString(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfString(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfString, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfString;
		if (size)
			*size = sizeof(ArrayOfString);
		((ArrayOfString*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfString[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfString);
		for (int i = 0; i < n; i++)
			((ArrayOfString*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfString*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfString(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfString %p -> %p\n", q, p));
	*(ArrayOfString*)p = *(ArrayOfString*)q;
}

void ArrayOfDeviceStateVariable::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfDeviceStateVariable::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfDeviceStateVariable))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__DeviceStateVariable(soap, this->__ptr + i);
		}
}

int ArrayOfDeviceStateVariable::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfDeviceStateVariable);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfDeviceStateVariable::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfDeviceStateVariable(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfDeviceStateVariable(struct soap *soap, const char *tag, int id, const ArrayOfDeviceStateVariable *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:DeviceStateVariable", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfDeviceStateVariable);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__DeviceStateVariable(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfDeviceStateVariable::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfDeviceStateVariable(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfDeviceStateVariable * SOAP_FMAC4 soap_get_ArrayOfDeviceStateVariable(struct soap *soap, ArrayOfDeviceStateVariable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfDeviceStateVariable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ArrayOfDeviceStateVariable::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfDeviceStateVariable(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfDeviceStateVariable * SOAP_FMAC4 soap_in_ArrayOfDeviceStateVariable(struct soap *soap, const char *tag, ArrayOfDeviceStateVariable *a, const char *type)
{	int i, j;
	ns1__DeviceStateVariable **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfDeviceStateVariable *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfDeviceStateVariable, sizeof(ArrayOfDeviceStateVariable), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__DeviceStateVariable **)soap_malloc(soap, sizeof(ns1__DeviceStateVariable *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__DeviceStateVariable(soap, NULL, a->__ptr + i, "ns1:DeviceStateVariable"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__DeviceStateVariable **)soap_push_block(soap, NULL, sizeof(ns1__DeviceStateVariable *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__DeviceStateVariable(soap, NULL, p, "ns1:DeviceStateVariable"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ns1__DeviceStateVariable **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfDeviceStateVariable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfDeviceStateVariable, 0, sizeof(ArrayOfDeviceStateVariable), 0, soap_copy_ArrayOfDeviceStateVariable);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfDeviceStateVariable * SOAP_FMAC6 soap_new_ArrayOfDeviceStateVariable(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfDeviceStateVariable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfDeviceStateVariable(struct soap *soap, ArrayOfDeviceStateVariable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfDeviceStateVariable * SOAP_FMAC4 soap_instantiate_ArrayOfDeviceStateVariable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfDeviceStateVariable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfDeviceStateVariable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfDeviceStateVariable;
		if (size)
			*size = sizeof(ArrayOfDeviceStateVariable);
		((ArrayOfDeviceStateVariable*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfDeviceStateVariable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfDeviceStateVariable);
		for (int i = 0; i < n; i++)
			((ArrayOfDeviceStateVariable*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfDeviceStateVariable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfDeviceStateVariable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfDeviceStateVariable %p -> %p\n", q, p));
	*(ArrayOfDeviceStateVariable*)p = *(ArrayOfDeviceStateVariable*)q;
}

void ArrayOfMessageEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfMessageEvent::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfMessageEvent))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__MessageEvent(soap, this->__ptr + i);
		}
}

int ArrayOfMessageEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfMessageEvent);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfMessageEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfMessageEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfMessageEvent(struct soap *soap, const char *tag, int id, const ArrayOfMessageEvent *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:MessageEvent", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfMessageEvent);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__MessageEvent(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfMessageEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfMessageEvent(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfMessageEvent * SOAP_FMAC4 soap_get_ArrayOfMessageEvent(struct soap *soap, ArrayOfMessageEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfMessageEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ArrayOfMessageEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfMessageEvent(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfMessageEvent * SOAP_FMAC4 soap_in_ArrayOfMessageEvent(struct soap *soap, const char *tag, ArrayOfMessageEvent *a, const char *type)
{	int i, j;
	ns1__MessageEvent **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfMessageEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfMessageEvent, sizeof(ArrayOfMessageEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__MessageEvent **)soap_malloc(soap, sizeof(ns1__MessageEvent *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__MessageEvent(soap, NULL, a->__ptr + i, "ns1:MessageEvent"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__MessageEvent **)soap_push_block(soap, NULL, sizeof(ns1__MessageEvent *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__MessageEvent(soap, NULL, p, "ns1:MessageEvent"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ns1__MessageEvent **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfMessageEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfMessageEvent, 0, sizeof(ArrayOfMessageEvent), 0, soap_copy_ArrayOfMessageEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfMessageEvent * SOAP_FMAC6 soap_new_ArrayOfMessageEvent(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfMessageEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfMessageEvent(struct soap *soap, ArrayOfMessageEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfMessageEvent * SOAP_FMAC4 soap_instantiate_ArrayOfMessageEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfMessageEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfMessageEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfMessageEvent;
		if (size)
			*size = sizeof(ArrayOfMessageEvent);
		((ArrayOfMessageEvent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfMessageEvent[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfMessageEvent);
		for (int i = 0; i < n; i++)
			((ArrayOfMessageEvent*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfMessageEvent*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfMessageEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfMessageEvent %p -> %p\n", q, p));
	*(ArrayOfMessageEvent*)p = *(ArrayOfMessageEvent*)q;
}

void ArrayOfDeviceStates::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfDeviceStates::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfDeviceStates))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__DeviceState(soap, this->__ptr + i);
		}
}

int ArrayOfDeviceStates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfDeviceStates);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfDeviceStates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfDeviceStates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfDeviceStates(struct soap *soap, const char *tag, int id, const ArrayOfDeviceStates *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptr ? soap_putsize(soap, "ns1:DeviceState", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfDeviceStates);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__DeviceState(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfDeviceStates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfDeviceStates(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfDeviceStates * SOAP_FMAC4 soap_get_ArrayOfDeviceStates(struct soap *soap, ArrayOfDeviceStates *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfDeviceStates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ArrayOfDeviceStates::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfDeviceStates(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfDeviceStates * SOAP_FMAC4 soap_in_ArrayOfDeviceStates(struct soap *soap, const char *tag, ArrayOfDeviceStates *a, const char *type)
{	int i, j;
	ns1__DeviceState **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfDeviceStates *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfDeviceStates, sizeof(ArrayOfDeviceStates), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__DeviceState **)soap_malloc(soap, sizeof(ns1__DeviceState *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__DeviceState(soap, NULL, a->__ptr + i, "ns1:DeviceState"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__DeviceState **)soap_push_block(soap, NULL, sizeof(ns1__DeviceState *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__DeviceState(soap, NULL, p, "ns1:DeviceState"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptr = (ns1__DeviceState **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfDeviceStates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfDeviceStates, 0, sizeof(ArrayOfDeviceStates), 0, soap_copy_ArrayOfDeviceStates);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfDeviceStates * SOAP_FMAC6 soap_new_ArrayOfDeviceStates(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfDeviceStates(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfDeviceStates(struct soap *soap, ArrayOfDeviceStates *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfDeviceStates * SOAP_FMAC4 soap_instantiate_ArrayOfDeviceStates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfDeviceStates(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfDeviceStates, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfDeviceStates;
		if (size)
			*size = sizeof(ArrayOfDeviceStates);
		((ArrayOfDeviceStates*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfDeviceStates[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfDeviceStates);
		for (int i = 0; i < n; i++)
			((ArrayOfDeviceStates*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfDeviceStates*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfDeviceStates(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfDeviceStates %p -> %p\n", q, p));
	*(ArrayOfDeviceStates*)p = *(ArrayOfDeviceStates*)q;
}

void ns1__DeviceStateVariable::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__DeviceStateVariable::variablename);
	soap_default_std__string(soap, &this->ns1__DeviceStateVariable::value);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__DeviceStateVariable::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__DeviceStateVariable::variablename, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DeviceStateVariable::variablename);
	soap_embedded(soap, &this->ns1__DeviceStateVariable::value, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DeviceStateVariable::value);
	/* transient soap skipped */
}

int ns1__DeviceStateVariable::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__DeviceStateVariable);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__DeviceStateVariable::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DeviceStateVariable(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeviceStateVariable(struct soap *soap, const char *tag, int id, const ns1__DeviceStateVariable *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeviceStateVariable), "ns1:DeviceStateVariable"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__string(soap, "variablename", -1, &(a->ns1__DeviceStateVariable::variablename), ""))
		return soap->error;
	if (soap_out_std__string(soap, "value", -1, &(a->ns1__DeviceStateVariable::value), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DeviceStateVariable::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DeviceStateVariable(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DeviceStateVariable * SOAP_FMAC4 soap_get_ns1__DeviceStateVariable(struct soap *soap, ns1__DeviceStateVariable *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeviceStateVariable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__DeviceStateVariable::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DeviceStateVariable(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DeviceStateVariable * SOAP_FMAC4 soap_in_ns1__DeviceStateVariable(struct soap *soap, const char *tag, ns1__DeviceStateVariable *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DeviceStateVariable *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeviceStateVariable, sizeof(ns1__DeviceStateVariable), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__DeviceStateVariable)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__DeviceStateVariable *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_variablename1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_variablename1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "variablename", &(a->ns1__DeviceStateVariable::variablename), "xsd:string"))
				{	soap_flag_variablename1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "value", &(a->ns1__DeviceStateVariable::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__DeviceStateVariable *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeviceStateVariable, 0, sizeof(ns1__DeviceStateVariable), 0, soap_copy_ns1__DeviceStateVariable);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_variablename1 > 0 || soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__DeviceStateVariable * SOAP_FMAC6 soap_new_ns1__DeviceStateVariable(struct soap *soap, int n)
{	return soap_instantiate_ns1__DeviceStateVariable(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__DeviceStateVariable(struct soap *soap, ns1__DeviceStateVariable *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__DeviceStateVariable * SOAP_FMAC4 soap_instantiate_ns1__DeviceStateVariable(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeviceStateVariable(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DeviceStateVariable, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__DeviceStateVariable;
		if (size)
			*size = sizeof(ns1__DeviceStateVariable);
		((ns1__DeviceStateVariable*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__DeviceStateVariable[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__DeviceStateVariable);
		for (int i = 0; i < n; i++)
			((ns1__DeviceStateVariable*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__DeviceStateVariable*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DeviceStateVariable(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__DeviceStateVariable %p -> %p\n", q, p));
	*(ns1__DeviceStateVariable*)p = *(ns1__DeviceStateVariable*)q;
}

void ns1__MessageEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->ns1__MessageEvent::id);
	soap_default_std__string(soap, &this->ns1__MessageEvent::sender);
	soap_default_std__string(soap, &this->ns1__MessageEvent::text);
	soap_default_time(soap, &this->ns1__MessageEvent::timestamp);
	soap_default_int(soap, &this->ns1__MessageEvent::type);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__MessageEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__MessageEvent::sender, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__MessageEvent::sender);
	soap_embedded(soap, &this->ns1__MessageEvent::text, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__MessageEvent::text);
	/* transient soap skipped */
}

int ns1__MessageEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MessageEvent);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MessageEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MessageEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MessageEvent(struct soap *soap, const char *tag, int id, const ns1__MessageEvent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MessageEvent), "ns1:MessageEvent"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_LONG64(soap, "id", -1, &(a->ns1__MessageEvent::id), ""))
		return soap->error;
	if (soap_out_std__string(soap, "sender", -1, &(a->ns1__MessageEvent::sender), ""))
		return soap->error;
	if (soap_out_std__string(soap, "text", -1, &(a->ns1__MessageEvent::text), ""))
		return soap->error;
	if (soap_out_time(soap, "timestamp", -1, &(a->ns1__MessageEvent::timestamp), ""))
		return soap->error;
	if (soap_out_int(soap, "type", -1, &(a->ns1__MessageEvent::type), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__MessageEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MessageEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MessageEvent * SOAP_FMAC4 soap_get_ns1__MessageEvent(struct soap *soap, ns1__MessageEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MessageEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__MessageEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MessageEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MessageEvent * SOAP_FMAC4 soap_in_ns1__MessageEvent(struct soap *soap, const char *tag, ns1__MessageEvent *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MessageEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MessageEvent, sizeof(ns1__MessageEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MessageEvent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MessageEvent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_sender1 = 1;
	size_t soap_flag_text1 = 1;
	size_t soap_flag_timestamp1 = 1;
	size_t soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_LONG64(soap, "id", &(a->ns1__MessageEvent::id), "xsd:long"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_sender1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sender", &(a->ns1__MessageEvent::sender), "xsd:string"))
				{	soap_flag_sender1--;
					continue;
				}
			if (soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "text", &(a->ns1__MessageEvent::text), "xsd:string"))
				{	soap_flag_text1--;
					continue;
				}
			if (soap_flag_timestamp1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "timestamp", &(a->ns1__MessageEvent::timestamp), "xsd:dateTime"))
				{	soap_flag_timestamp1--;
					continue;
				}
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "type", &(a->ns1__MessageEvent::type), "xsd:int"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MessageEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MessageEvent, 0, sizeof(ns1__MessageEvent), 0, soap_copy_ns1__MessageEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_sender1 > 0 || soap_flag_text1 > 0 || soap_flag_timestamp1 > 0 || soap_flag_type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MessageEvent * SOAP_FMAC6 soap_new_ns1__MessageEvent(struct soap *soap, int n)
{	return soap_instantiate_ns1__MessageEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MessageEvent(struct soap *soap, ns1__MessageEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MessageEvent * SOAP_FMAC4 soap_instantiate_ns1__MessageEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MessageEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MessageEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MessageEvent;
		if (size)
			*size = sizeof(ns1__MessageEvent);
		((ns1__MessageEvent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MessageEvent[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MessageEvent);
		for (int i = 0; i < n; i++)
			((ns1__MessageEvent*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MessageEvent*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MessageEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MessageEvent %p -> %p\n", q, p));
	*(ns1__MessageEvent*)p = *(ns1__MessageEvent*)q;
}

void ns1__DeviceState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__DeviceState::id);
	soap_default_std__string(soap, &this->ns1__DeviceState::name);
	soap_default_std__string(soap, &this->ns1__DeviceState::username);
	soap_default_std__string(soap, &this->ns1__DeviceState::status);
	soap_default_std__string(soap, &this->ns1__DeviceState::text);
	soap_default_int(soap, &this->ns1__DeviceState::state);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void ns1__DeviceState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__DeviceState::id, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DeviceState::id);
	soap_embedded(soap, &this->ns1__DeviceState::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DeviceState::name);
	soap_embedded(soap, &this->ns1__DeviceState::username, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DeviceState::username);
	soap_embedded(soap, &this->ns1__DeviceState::status, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DeviceState::status);
	soap_embedded(soap, &this->ns1__DeviceState::text, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__DeviceState::text);
	/* transient soap skipped */
}

int ns1__DeviceState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__DeviceState);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__DeviceState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__DeviceState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeviceState(struct soap *soap, const char *tag, int id, const ns1__DeviceState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeviceState), "ns1:DeviceState"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_std__string(soap, "id", -1, &(a->ns1__DeviceState::id), ""))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->ns1__DeviceState::name), ""))
		return soap->error;
	if (soap_out_std__string(soap, "username", -1, &(a->ns1__DeviceState::username), ""))
		return soap->error;
	if (soap_out_std__string(soap, "status", -1, &(a->ns1__DeviceState::status), ""))
		return soap->error;
	if (soap_out_std__string(soap, "text", -1, &(a->ns1__DeviceState::text), ""))
		return soap->error;
	if (soap_out_int(soap, "state", -1, &(a->ns1__DeviceState::state), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__DeviceState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__DeviceState(soap, this, tag, type);
}

SOAP_FMAC3 ns1__DeviceState * SOAP_FMAC4 soap_get_ns1__DeviceState(struct soap *soap, ns1__DeviceState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeviceState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__DeviceState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__DeviceState(soap, tag, this, type);
}

SOAP_FMAC3 ns1__DeviceState * SOAP_FMAC4 soap_in_ns1__DeviceState(struct soap *soap, const char *tag, ns1__DeviceState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__DeviceState *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeviceState, sizeof(ns1__DeviceState), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__DeviceState)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__DeviceState *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_id1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_username1 = 1;
	size_t soap_flag_status1 = 1;
	size_t soap_flag_text1 = 1;
	size_t soap_flag_state1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "id", &(a->ns1__DeviceState::id), "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->ns1__DeviceState::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_username1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "username", &(a->ns1__DeviceState::username), "xsd:string"))
				{	soap_flag_username1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "status", &(a->ns1__DeviceState::status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_text1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "text", &(a->ns1__DeviceState::text), "xsd:string"))
				{	soap_flag_text1--;
					continue;
				}
			if (soap_flag_state1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "state", &(a->ns1__DeviceState::state), "xsd:int"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__DeviceState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeviceState, 0, sizeof(ns1__DeviceState), 0, soap_copy_ns1__DeviceState);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_name1 > 0 || soap_flag_username1 > 0 || soap_flag_status1 > 0 || soap_flag_text1 > 0 || soap_flag_state1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__DeviceState * SOAP_FMAC6 soap_new_ns1__DeviceState(struct soap *soap, int n)
{	return soap_instantiate_ns1__DeviceState(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__DeviceState(struct soap *soap, ns1__DeviceState *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__DeviceState * SOAP_FMAC4 soap_instantiate_ns1__DeviceState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__DeviceState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__DeviceState, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__DeviceState;
		if (size)
			*size = sizeof(ns1__DeviceState);
		((ns1__DeviceState*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__DeviceState[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__DeviceState);
		for (int i = 0; i < n; i++)
			((ns1__DeviceState*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__DeviceState*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__DeviceState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__DeviceState %p -> %p\n", q, p));
	*(ns1__DeviceState*)p = *(ns1__DeviceState*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void xsd__string::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->xsd__string::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__string::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->xsd__string::__item, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->xsd__string::__item);
	/* transient soap skipped */
}

int xsd__string::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__string);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__string::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__string(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, const xsd__string *a, const char *type)
{
	return soap_out_std__string(soap, tag, id, &(a->xsd__string::__item), "xsd:string");
}

void *xsd__string::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__string(soap, this, tag, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, xsd__string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__string::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__string(soap, tag, this, type);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, xsd__string *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__string *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__string, sizeof(xsd__string), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__string)
			return (xsd__string *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_std__string(soap, tag, &(a->xsd__string::__item), "xsd:string"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__string * SOAP_FMAC6 soap_new_xsd__string(struct soap *soap, int n)
{	return soap_instantiate_xsd__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__string(struct soap *soap, xsd__string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__string * SOAP_FMAC4 soap_instantiate_xsd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__string;
		if (size)
			*size = sizeof(xsd__string);
		((xsd__string*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__string);
		for (int i = 0; i < n; i++)
			((xsd__string*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__string %p -> %p\n", q, p));
	*(xsd__string*)p = *(xsd__string*)q;
}

void xsd__long::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_LONG64(soap, &this->xsd__long::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__long::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__long::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__long);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__long::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__long(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__long(struct soap *soap, const char *tag, int id, const xsd__long *a, const char *type)
{
	return soap_out_LONG64(soap, tag, id, &(a->xsd__long::__item), "xsd:long");
}

void *xsd__long::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__long(soap, this, tag, type);
}

SOAP_FMAC3 xsd__long * SOAP_FMAC4 soap_get_xsd__long(struct soap *soap, xsd__long *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__long(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__long::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__long(soap, tag, this, type);
}

SOAP_FMAC3 xsd__long * SOAP_FMAC4 soap_in_xsd__long(struct soap *soap, const char *tag, xsd__long *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__long *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__long, sizeof(xsd__long), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__long)
			return (xsd__long *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_LONG64(soap, tag, &(a->xsd__long::__item), "xsd:long"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__long * SOAP_FMAC6 soap_new_xsd__long(struct soap *soap, int n)
{	return soap_instantiate_xsd__long(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__long(struct soap *soap, xsd__long *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__long * SOAP_FMAC4 soap_instantiate_xsd__long(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__long(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__long, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__long;
		if (size)
			*size = sizeof(xsd__long);
		((xsd__long*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__long[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__long);
		for (int i = 0; i < n; i++)
			((xsd__long*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__long*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__long(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__long %p -> %p\n", q, p));
	*(xsd__long*)p = *(xsd__long*)q;
}

void xsd__int::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->xsd__int::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__int::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__int::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__int);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__int::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__int(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const xsd__int *a, const char *type)
{
	return soap_out_int(soap, tag, id, &(a->xsd__int::__item), "xsd:int");
}

void *xsd__int::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__int(soap, this, tag, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_get_xsd__int(struct soap *soap, xsd__int *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__int::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__int(soap, tag, this, type);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_in_xsd__int(struct soap *soap, const char *tag, xsd__int *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__int *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__int, sizeof(xsd__int), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__int)
			return (xsd__int *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_int(soap, tag, &(a->xsd__int::__item), "xsd:int"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__int * SOAP_FMAC6 soap_new_xsd__int(struct soap *soap, int n)
{	return soap_instantiate_xsd__int(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__int(struct soap *soap, xsd__int *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__int * SOAP_FMAC4 soap_instantiate_xsd__int(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__int(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__int, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__int;
		if (size)
			*size = sizeof(xsd__int);
		((xsd__int*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__int[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__int);
		for (int i = 0; i < n; i++)
			((xsd__int*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__int*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__int(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__int %p -> %p\n", q, p));
	*(xsd__int*)p = *(xsd__int*)q;
}

void xsd__dateTime::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->xsd__dateTime::__item);
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__dateTime::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__dateTime::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__dateTime);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__dateTime::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__dateTime(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__dateTime(struct soap *soap, const char *tag, int id, const xsd__dateTime *a, const char *type)
{
	return soap_out_time(soap, tag, id, &(a->xsd__dateTime::__item), "xsd:dateTime");
}

void *xsd__dateTime::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__dateTime(soap, this, tag, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_get_xsd__dateTime(struct soap *soap, xsd__dateTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__dateTime::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__dateTime(soap, tag, this, type);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_in_xsd__dateTime(struct soap *soap, const char *tag, xsd__dateTime *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__dateTime *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__dateTime, sizeof(xsd__dateTime), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__dateTime)
			return (xsd__dateTime *)a->soap_in(soap, tag, type);
	}
	if (!soap_in_time(soap, tag, &(a->xsd__dateTime::__item), "xsd:dateTime"))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__dateTime * SOAP_FMAC6 soap_new_xsd__dateTime(struct soap *soap, int n)
{	return soap_instantiate_xsd__dateTime(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__dateTime(struct soap *soap, xsd__dateTime *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__dateTime * SOAP_FMAC4 soap_instantiate_xsd__dateTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__dateTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__dateTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new xsd__dateTime;
		if (size)
			*size = sizeof(xsd__dateTime);
		((xsd__dateTime*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__dateTime[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__dateTime);
		for (int i = 0; i < n; i++)
			((xsd__dateTime*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__dateTime*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__dateTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__dateTime %p -> %p\n", q, p));
	*(xsd__dateTime*)p = *(xsd__dateTime*)q;
}

void xsd__anyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
	/* transient soap skipped */
}

void xsd__anyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_xsd__anyType);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a, const char *type)
{
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), NULL);
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_xsd__anyType)
			return (xsd__anyType *)a->soap_in(soap, tag, type);
	}
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

SOAP_FMAC5 xsd__anyType * SOAP_FMAC6 soap_new_xsd__anyType(struct soap *soap, int n)
{	return soap_instantiate_xsd__anyType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__anyType(struct soap *soap, xsd__anyType *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "xsd:dateTime"))
	{	cp->type = SOAP_TYPE_xsd__dateTime;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__dateTime;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__dateTime);
			((xsd__dateTime*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__dateTime[n];
			if (size)
				*size = n * sizeof(xsd__dateTime);
			for (int i = 0; i < n; i++)
				((xsd__dateTime*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__dateTime*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:int"))
	{	cp->type = SOAP_TYPE_xsd__int;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__int;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__int);
			((xsd__int*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__int[n];
			if (size)
				*size = n * sizeof(xsd__int);
			for (int i = 0; i < n; i++)
				((xsd__int*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__int*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:long"))
	{	cp->type = SOAP_TYPE_xsd__long;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__long;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__long);
			((xsd__long*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__long[n];
			if (size)
				*size = n * sizeof(xsd__long);
			for (int i = 0; i < n; i++)
				((xsd__long*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__long*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "xsd:string"))
	{	cp->type = SOAP_TYPE_xsd__string;
		if (n < 0)
		{	cp->ptr = (void*)new xsd__string;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(xsd__string);
			((xsd__string*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new xsd__string[n];
			if (size)
				*size = n * sizeof(xsd__string);
			for (int i = 0; i < n; i++)
				((xsd__string*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (xsd__string*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:DeviceState"))
	{	cp->type = SOAP_TYPE_ns1__DeviceState;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__DeviceState;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__DeviceState);
			((ns1__DeviceState*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__DeviceState[n];
			if (size)
				*size = n * sizeof(ns1__DeviceState);
			for (int i = 0; i < n; i++)
				((ns1__DeviceState*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__DeviceState*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:MessageEvent"))
	{	cp->type = SOAP_TYPE_ns1__MessageEvent;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__MessageEvent;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__MessageEvent);
			((ns1__MessageEvent*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__MessageEvent[n];
			if (size)
				*size = n * sizeof(ns1__MessageEvent);
			for (int i = 0; i < n; i++)
				((ns1__MessageEvent*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__MessageEvent*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:DeviceStateVariable"))
	{	cp->type = SOAP_TYPE_ns1__DeviceStateVariable;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__DeviceStateVariable;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__DeviceStateVariable);
			((ns1__DeviceStateVariable*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__DeviceStateVariable[n];
			if (size)
				*size = n * sizeof(ns1__DeviceStateVariable);
			for (int i = 0; i < n; i++)
				((ns1__DeviceStateVariable*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__DeviceStateVariable*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "ns1:DeviceStateEx"))
	{	cp->type = SOAP_TYPE_ns1__DeviceStateEx;
		if (n < 0)
		{	cp->ptr = (void*)new ns1__DeviceStateEx;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__DeviceStateEx);
			((ns1__DeviceStateEx*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ns1__DeviceStateEx[n];
			if (size)
				*size = n * sizeof(ns1__DeviceStateEx);
			for (int i = 0; i < n; i++)
				((ns1__DeviceStateEx*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__DeviceStateEx*)cp->ptr;
	}
	if (arrayType && !soap_match_tag(soap, arrayType, "ns1:DeviceState"))
	{	cp->type = SOAP_TYPE_ArrayOfDeviceStates;
		if (n < 0)
		{	cp->ptr = (void*)new ArrayOfDeviceStates;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ArrayOfDeviceStates);
			((ArrayOfDeviceStates*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ArrayOfDeviceStates[n];
			if (size)
				*size = n * sizeof(ArrayOfDeviceStates);
			for (int i = 0; i < n; i++)
				((ArrayOfDeviceStates*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ArrayOfDeviceStates*)cp->ptr;
	}
	if (arrayType && !soap_match_tag(soap, arrayType, "ns1:MessageEvent"))
	{	cp->type = SOAP_TYPE_ArrayOfMessageEvent;
		if (n < 0)
		{	cp->ptr = (void*)new ArrayOfMessageEvent;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ArrayOfMessageEvent);
			((ArrayOfMessageEvent*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ArrayOfMessageEvent[n];
			if (size)
				*size = n * sizeof(ArrayOfMessageEvent);
			for (int i = 0; i < n; i++)
				((ArrayOfMessageEvent*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ArrayOfMessageEvent*)cp->ptr;
	}
	if (arrayType && !soap_match_tag(soap, arrayType, "ns1:DeviceStateVariable"))
	{	cp->type = SOAP_TYPE_ArrayOfDeviceStateVariable;
		if (n < 0)
		{	cp->ptr = (void*)new ArrayOfDeviceStateVariable;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ArrayOfDeviceStateVariable);
			((ArrayOfDeviceStateVariable*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ArrayOfDeviceStateVariable[n];
			if (size)
				*size = n * sizeof(ArrayOfDeviceStateVariable);
			for (int i = 0; i < n; i++)
				((ArrayOfDeviceStateVariable*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ArrayOfDeviceStateVariable*)cp->ptr;
	}
	if (arrayType && !soap_match_tag(soap, arrayType, "xsd:string"))
	{	cp->type = SOAP_TYPE_ArrayOfString;
		if (n < 0)
		{	cp->ptr = (void*)new ArrayOfString;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ArrayOfString);
			((ArrayOfString*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ArrayOfString[n];
			if (size)
				*size = n * sizeof(ArrayOfString);
			for (int i = 0; i < n; i++)
				((ArrayOfString*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ArrayOfString*)cp->ptr;
	}
	if (arrayType && !soap_match_tag(soap, arrayType, "xsd:anyType"))
	{	cp->type = SOAP_TYPE_ArrayOfAnyType;
		if (n < 0)
		{	cp->ptr = (void*)new ArrayOfAnyType;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ArrayOfAnyType);
			((ArrayOfAnyType*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ArrayOfAnyType[n];
			if (size)
				*size = n * sizeof(ArrayOfAnyType);
			for (int i = 0; i < n; i++)
				((ArrayOfAnyType*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ArrayOfAnyType*)cp->ptr;
	}
	if (arrayType && !soap_match_tag(soap, arrayType, "ns1:DeviceStateEx"))
	{	cp->type = SOAP_TYPE_ArrayOfDeviceStatesEx;
		if (n < 0)
		{	cp->ptr = (void*)new ArrayOfDeviceStatesEx;
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ArrayOfDeviceStatesEx);
			((ArrayOfDeviceStatesEx*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)new ArrayOfDeviceStatesEx[n];
			if (size)
				*size = n * sizeof(ArrayOfDeviceStatesEx);
			for (int i = 0; i < n; i++)
				((ArrayOfDeviceStatesEx*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ArrayOfDeviceStatesEx*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)new xsd__anyType;
		if (size)
			*size = sizeof(xsd__anyType);
		((xsd__anyType*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new xsd__anyType[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(xsd__anyType);
		for (int i = 0; i < n; i++)
			((xsd__anyType*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (xsd__anyType*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__anyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying xsd__anyType %p -> %p\n", q, p));
	*(xsd__anyType*)p = *(xsd__anyType*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDeviceAvailableActions(struct soap *soap, struct ns1__getDeviceAvailableActions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->deviceID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDeviceAvailableActions(struct soap *soap, const struct ns1__getDeviceAvailableActions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->deviceID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->deviceID);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDeviceAvailableActions(struct soap *soap, const struct ns1__getDeviceAvailableActions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDeviceAvailableActions);
	if (soap_out_ns1__getDeviceAvailableActions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDeviceAvailableActions(struct soap *soap, const char *tag, int id, const struct ns1__getDeviceAvailableActions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDeviceAvailableActions), type))
		return soap->error;
	if (soap_out_std__string(soap, "deviceID", -1, &a->deviceID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDeviceAvailableActions * SOAP_FMAC4 soap_get_ns1__getDeviceAvailableActions(struct soap *soap, struct ns1__getDeviceAvailableActions *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDeviceAvailableActions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getDeviceAvailableActions * SOAP_FMAC4 soap_in_ns1__getDeviceAvailableActions(struct soap *soap, const char *tag, struct ns1__getDeviceAvailableActions *a, const char *type)
{
	size_t soap_flag_deviceID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDeviceAvailableActions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDeviceAvailableActions, sizeof(struct ns1__getDeviceAvailableActions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getDeviceAvailableActions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "deviceID", &a->deviceID, "xsd:string"))
				{	soap_flag_deviceID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDeviceAvailableActions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDeviceAvailableActions, 0, sizeof(struct ns1__getDeviceAvailableActions), 0, soap_copy_ns1__getDeviceAvailableActions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__getDeviceAvailableActions * SOAP_FMAC6 soap_new_ns1__getDeviceAvailableActions(struct soap *soap, int n)
{	return soap_instantiate_ns1__getDeviceAvailableActions(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getDeviceAvailableActions(struct soap *soap, struct ns1__getDeviceAvailableActions *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__getDeviceAvailableActions * SOAP_FMAC4 soap_instantiate_ns1__getDeviceAvailableActions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDeviceAvailableActions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDeviceAvailableActions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__getDeviceAvailableActions;
		if (size)
			*size = sizeof(struct ns1__getDeviceAvailableActions);
	}
	else
	{	cp->ptr = (void*)new struct ns1__getDeviceAvailableActions[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getDeviceAvailableActions);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getDeviceAvailableActions*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDeviceAvailableActions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDeviceAvailableActions %p -> %p\n", q, p));
	*(struct ns1__getDeviceAvailableActions*)p = *(struct ns1__getDeviceAvailableActions*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDeviceAvailableActionsResponse(struct soap *soap, struct ns1__getDeviceAvailableActionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDeviceAvailableActionsResponse(struct soap *soap, const struct ns1__getDeviceAvailableActionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfString(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDeviceAvailableActionsResponse(struct soap *soap, const struct ns1__getDeviceAvailableActionsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDeviceAvailableActionsResponse);
	if (soap_out_ns1__getDeviceAvailableActionsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDeviceAvailableActionsResponse(struct soap *soap, const char *tag, int id, const struct ns1__getDeviceAvailableActionsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDeviceAvailableActionsResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfString(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDeviceAvailableActionsResponse * SOAP_FMAC4 soap_get_ns1__getDeviceAvailableActionsResponse(struct soap *soap, struct ns1__getDeviceAvailableActionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDeviceAvailableActionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getDeviceAvailableActionsResponse * SOAP_FMAC4 soap_in_ns1__getDeviceAvailableActionsResponse(struct soap *soap, const char *tag, struct ns1__getDeviceAvailableActionsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDeviceAvailableActionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDeviceAvailableActionsResponse, sizeof(struct ns1__getDeviceAvailableActionsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDeviceAvailableActionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfString(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDeviceAvailableActionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDeviceAvailableActionsResponse, 0, sizeof(struct ns1__getDeviceAvailableActionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__getDeviceAvailableActionsResponse * SOAP_FMAC6 soap_new_ns1__getDeviceAvailableActionsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getDeviceAvailableActionsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getDeviceAvailableActionsResponse(struct soap *soap, struct ns1__getDeviceAvailableActionsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__getDeviceAvailableActionsResponse * SOAP_FMAC4 soap_instantiate_ns1__getDeviceAvailableActionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDeviceAvailableActionsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDeviceAvailableActionsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__getDeviceAvailableActionsResponse;
		if (size)
			*size = sizeof(struct ns1__getDeviceAvailableActionsResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__getDeviceAvailableActionsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getDeviceAvailableActionsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getDeviceAvailableActionsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDeviceAvailableActionsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDeviceAvailableActionsResponse %p -> %p\n", q, p));
	*(struct ns1__getDeviceAvailableActionsResponse*)p = *(struct ns1__getDeviceAvailableActionsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDeviceStateVariables(struct soap *soap, struct ns1__getDeviceStateVariables *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->deviceID);
	a->variableNames = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDeviceStateVariables(struct soap *soap, const struct ns1__getDeviceStateVariables *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->deviceID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->deviceID);
	soap_serialize_PointerToArrayOfString(soap, &a->variableNames);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDeviceStateVariables(struct soap *soap, const struct ns1__getDeviceStateVariables *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDeviceStateVariables);
	if (soap_out_ns1__getDeviceStateVariables(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDeviceStateVariables(struct soap *soap, const char *tag, int id, const struct ns1__getDeviceStateVariables *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDeviceStateVariables), type))
		return soap->error;
	if (soap_out_std__string(soap, "deviceID", -1, &a->deviceID, ""))
		return soap->error;
	if (soap_out_PointerToArrayOfString(soap, "variableNames", -1, &a->variableNames, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDeviceStateVariables * SOAP_FMAC4 soap_get_ns1__getDeviceStateVariables(struct soap *soap, struct ns1__getDeviceStateVariables *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDeviceStateVariables(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getDeviceStateVariables * SOAP_FMAC4 soap_in_ns1__getDeviceStateVariables(struct soap *soap, const char *tag, struct ns1__getDeviceStateVariables *a, const char *type)
{
	size_t soap_flag_deviceID = 1;
	size_t soap_flag_variableNames = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDeviceStateVariables *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDeviceStateVariables, sizeof(struct ns1__getDeviceStateVariables), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getDeviceStateVariables(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "deviceID", &a->deviceID, "xsd:string"))
				{	soap_flag_deviceID--;
					continue;
				}
			if (soap_flag_variableNames && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfString(soap, "variableNames", &a->variableNames, "xsd:string"))
				{	soap_flag_variableNames--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDeviceStateVariables *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDeviceStateVariables, 0, sizeof(struct ns1__getDeviceStateVariables), 0, soap_copy_ns1__getDeviceStateVariables);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deviceID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__getDeviceStateVariables * SOAP_FMAC6 soap_new_ns1__getDeviceStateVariables(struct soap *soap, int n)
{	return soap_instantiate_ns1__getDeviceStateVariables(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getDeviceStateVariables(struct soap *soap, struct ns1__getDeviceStateVariables *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__getDeviceStateVariables * SOAP_FMAC4 soap_instantiate_ns1__getDeviceStateVariables(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDeviceStateVariables(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDeviceStateVariables, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__getDeviceStateVariables;
		if (size)
			*size = sizeof(struct ns1__getDeviceStateVariables);
	}
	else
	{	cp->ptr = (void*)new struct ns1__getDeviceStateVariables[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getDeviceStateVariables);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getDeviceStateVariables*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDeviceStateVariables(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDeviceStateVariables %p -> %p\n", q, p));
	*(struct ns1__getDeviceStateVariables*)p = *(struct ns1__getDeviceStateVariables*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDeviceStateVariablesResponse(struct soap *soap, struct ns1__getDeviceStateVariablesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDeviceStateVariablesResponse(struct soap *soap, const struct ns1__getDeviceStateVariablesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfDeviceStateVariable(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDeviceStateVariablesResponse(struct soap *soap, const struct ns1__getDeviceStateVariablesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDeviceStateVariablesResponse);
	if (soap_out_ns1__getDeviceStateVariablesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDeviceStateVariablesResponse(struct soap *soap, const char *tag, int id, const struct ns1__getDeviceStateVariablesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDeviceStateVariablesResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfDeviceStateVariable(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDeviceStateVariablesResponse * SOAP_FMAC4 soap_get_ns1__getDeviceStateVariablesResponse(struct soap *soap, struct ns1__getDeviceStateVariablesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDeviceStateVariablesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getDeviceStateVariablesResponse * SOAP_FMAC4 soap_in_ns1__getDeviceStateVariablesResponse(struct soap *soap, const char *tag, struct ns1__getDeviceStateVariablesResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDeviceStateVariablesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDeviceStateVariablesResponse, sizeof(struct ns1__getDeviceStateVariablesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDeviceStateVariablesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfDeviceStateVariable(soap, "return", &a->return_, "ns1:DeviceStateVariable"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDeviceStateVariablesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDeviceStateVariablesResponse, 0, sizeof(struct ns1__getDeviceStateVariablesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__getDeviceStateVariablesResponse * SOAP_FMAC6 soap_new_ns1__getDeviceStateVariablesResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getDeviceStateVariablesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getDeviceStateVariablesResponse(struct soap *soap, struct ns1__getDeviceStateVariablesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__getDeviceStateVariablesResponse * SOAP_FMAC4 soap_instantiate_ns1__getDeviceStateVariablesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDeviceStateVariablesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDeviceStateVariablesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__getDeviceStateVariablesResponse;
		if (size)
			*size = sizeof(struct ns1__getDeviceStateVariablesResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__getDeviceStateVariablesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getDeviceStateVariablesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getDeviceStateVariablesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDeviceStateVariablesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDeviceStateVariablesResponse %p -> %p\n", q, p));
	*(struct ns1__getDeviceStateVariablesResponse*)p = *(struct ns1__getDeviceStateVariablesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getLastDevicesEvents(struct soap *soap, struct ns1__getLastDevicesEvents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->since);
	soap_default_std__string(soap, &a->lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getLastDevicesEvents(struct soap *soap, const struct ns1__getLastDevicesEvents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->lang, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->lang);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getLastDevicesEvents(struct soap *soap, const struct ns1__getLastDevicesEvents *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getLastDevicesEvents);
	if (soap_out_ns1__getLastDevicesEvents(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getLastDevicesEvents(struct soap *soap, const char *tag, int id, const struct ns1__getLastDevicesEvents *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getLastDevicesEvents), type))
		return soap->error;
	if (soap_out_time(soap, "since", -1, &a->since, ""))
		return soap->error;
	if (soap_out_std__string(soap, "lang", -1, &a->lang, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getLastDevicesEvents * SOAP_FMAC4 soap_get_ns1__getLastDevicesEvents(struct soap *soap, struct ns1__getLastDevicesEvents *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getLastDevicesEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getLastDevicesEvents * SOAP_FMAC4 soap_in_ns1__getLastDevicesEvents(struct soap *soap, const char *tag, struct ns1__getLastDevicesEvents *a, const char *type)
{
	size_t soap_flag_since = 1;
	size_t soap_flag_lang = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getLastDevicesEvents *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getLastDevicesEvents, sizeof(struct ns1__getLastDevicesEvents), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getLastDevicesEvents(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_since && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "since", &a->since, "xsd:dateTime"))
				{	soap_flag_since--;
					continue;
				}
			if (soap_flag_lang && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "lang", &a->lang, "xsd:string"))
				{	soap_flag_lang--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getLastDevicesEvents *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getLastDevicesEvents, 0, sizeof(struct ns1__getLastDevicesEvents), 0, soap_copy_ns1__getLastDevicesEvents);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_since > 0 || soap_flag_lang > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__getLastDevicesEvents * SOAP_FMAC6 soap_new_ns1__getLastDevicesEvents(struct soap *soap, int n)
{	return soap_instantiate_ns1__getLastDevicesEvents(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getLastDevicesEvents(struct soap *soap, struct ns1__getLastDevicesEvents *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__getLastDevicesEvents * SOAP_FMAC4 soap_instantiate_ns1__getLastDevicesEvents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getLastDevicesEvents(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getLastDevicesEvents, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__getLastDevicesEvents;
		if (size)
			*size = sizeof(struct ns1__getLastDevicesEvents);
	}
	else
	{	cp->ptr = (void*)new struct ns1__getLastDevicesEvents[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getLastDevicesEvents);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getLastDevicesEvents*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getLastDevicesEvents(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getLastDevicesEvents %p -> %p\n", q, p));
	*(struct ns1__getLastDevicesEvents*)p = *(struct ns1__getLastDevicesEvents*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getLastDevicesEventsResponse(struct soap *soap, struct ns1__getLastDevicesEventsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getLastDevicesEventsResponse(struct soap *soap, const struct ns1__getLastDevicesEventsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfMessageEvent(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getLastDevicesEventsResponse(struct soap *soap, const struct ns1__getLastDevicesEventsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getLastDevicesEventsResponse);
	if (soap_out_ns1__getLastDevicesEventsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getLastDevicesEventsResponse(struct soap *soap, const char *tag, int id, const struct ns1__getLastDevicesEventsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getLastDevicesEventsResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfMessageEvent(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getLastDevicesEventsResponse * SOAP_FMAC4 soap_get_ns1__getLastDevicesEventsResponse(struct soap *soap, struct ns1__getLastDevicesEventsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getLastDevicesEventsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getLastDevicesEventsResponse * SOAP_FMAC4 soap_in_ns1__getLastDevicesEventsResponse(struct soap *soap, const char *tag, struct ns1__getLastDevicesEventsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getLastDevicesEventsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getLastDevicesEventsResponse, sizeof(struct ns1__getLastDevicesEventsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getLastDevicesEventsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfMessageEvent(soap, "return", &a->return_, "ns1:MessageEvent"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getLastDevicesEventsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getLastDevicesEventsResponse, 0, sizeof(struct ns1__getLastDevicesEventsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__getLastDevicesEventsResponse * SOAP_FMAC6 soap_new_ns1__getLastDevicesEventsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getLastDevicesEventsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getLastDevicesEventsResponse(struct soap *soap, struct ns1__getLastDevicesEventsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__getLastDevicesEventsResponse * SOAP_FMAC4 soap_instantiate_ns1__getLastDevicesEventsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getLastDevicesEventsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getLastDevicesEventsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__getLastDevicesEventsResponse;
		if (size)
			*size = sizeof(struct ns1__getLastDevicesEventsResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__getLastDevicesEventsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getLastDevicesEventsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getLastDevicesEventsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getLastDevicesEventsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getLastDevicesEventsResponse %p -> %p\n", q, p));
	*(struct ns1__getLastDevicesEventsResponse*)p = *(struct ns1__getLastDevicesEventsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__invokeAction(struct soap *soap, struct ns1__invokeAction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->deviceID);
	soap_default_std__string(soap, &a->actionName);
	a->parameters = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__invokeAction(struct soap *soap, const struct ns1__invokeAction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->deviceID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->deviceID);
	soap_embedded(soap, &a->actionName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->actionName);
	soap_serialize_PointerToArrayOfString(soap, &a->parameters);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__invokeAction(struct soap *soap, const struct ns1__invokeAction *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__invokeAction);
	if (soap_out_ns1__invokeAction(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__invokeAction(struct soap *soap, const char *tag, int id, const struct ns1__invokeAction *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__invokeAction), type))
		return soap->error;
	if (soap_out_std__string(soap, "deviceID", -1, &a->deviceID, ""))
		return soap->error;
	if (soap_out_std__string(soap, "actionName", -1, &a->actionName, ""))
		return soap->error;
	if (soap_out_PointerToArrayOfString(soap, "parameters", -1, &a->parameters, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__invokeAction * SOAP_FMAC4 soap_get_ns1__invokeAction(struct soap *soap, struct ns1__invokeAction *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__invokeAction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__invokeAction * SOAP_FMAC4 soap_in_ns1__invokeAction(struct soap *soap, const char *tag, struct ns1__invokeAction *a, const char *type)
{
	size_t soap_flag_deviceID = 1;
	size_t soap_flag_actionName = 1;
	size_t soap_flag_parameters = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__invokeAction *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__invokeAction, sizeof(struct ns1__invokeAction), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__invokeAction(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "deviceID", &a->deviceID, "xsd:string"))
				{	soap_flag_deviceID--;
					continue;
				}
			if (soap_flag_actionName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "actionName", &a->actionName, "xsd:string"))
				{	soap_flag_actionName--;
					continue;
				}
			if (soap_flag_parameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfString(soap, "parameters", &a->parameters, "xsd:string"))
				{	soap_flag_parameters--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__invokeAction *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__invokeAction, 0, sizeof(struct ns1__invokeAction), 0, soap_copy_ns1__invokeAction);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deviceID > 0 || soap_flag_actionName > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__invokeAction * SOAP_FMAC6 soap_new_ns1__invokeAction(struct soap *soap, int n)
{	return soap_instantiate_ns1__invokeAction(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__invokeAction(struct soap *soap, struct ns1__invokeAction *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__invokeAction * SOAP_FMAC4 soap_instantiate_ns1__invokeAction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__invokeAction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__invokeAction, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__invokeAction;
		if (size)
			*size = sizeof(struct ns1__invokeAction);
	}
	else
	{	cp->ptr = (void*)new struct ns1__invokeAction[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__invokeAction);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__invokeAction*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__invokeAction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__invokeAction %p -> %p\n", q, p));
	*(struct ns1__invokeAction*)p = *(struct ns1__invokeAction*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__invokeActionResponse(struct soap *soap, struct ns1__invokeActionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__invokeActionResponse(struct soap *soap, const struct ns1__invokeActionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfAnyType(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__invokeActionResponse(struct soap *soap, const struct ns1__invokeActionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__invokeActionResponse);
	if (soap_out_ns1__invokeActionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__invokeActionResponse(struct soap *soap, const char *tag, int id, const struct ns1__invokeActionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__invokeActionResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfAnyType(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__invokeActionResponse * SOAP_FMAC4 soap_get_ns1__invokeActionResponse(struct soap *soap, struct ns1__invokeActionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__invokeActionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__invokeActionResponse * SOAP_FMAC4 soap_in_ns1__invokeActionResponse(struct soap *soap, const char *tag, struct ns1__invokeActionResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__invokeActionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__invokeActionResponse, sizeof(struct ns1__invokeActionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__invokeActionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAnyType(soap, "return", &a->return_, "xsd:anyType"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__invokeActionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__invokeActionResponse, 0, sizeof(struct ns1__invokeActionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__invokeActionResponse * SOAP_FMAC6 soap_new_ns1__invokeActionResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__invokeActionResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__invokeActionResponse(struct soap *soap, struct ns1__invokeActionResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__invokeActionResponse * SOAP_FMAC4 soap_instantiate_ns1__invokeActionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__invokeActionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__invokeActionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__invokeActionResponse;
		if (size)
			*size = sizeof(struct ns1__invokeActionResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__invokeActionResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__invokeActionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__invokeActionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__invokeActionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__invokeActionResponse %p -> %p\n", q, p));
	*(struct ns1__invokeActionResponse*)p = *(struct ns1__invokeActionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAllDevicesOverviewExtendedData(struct soap *soap, struct ns1__getAllDevicesOverviewExtendedData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->locale);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAllDevicesOverviewExtendedData(struct soap *soap, const struct ns1__getAllDevicesOverviewExtendedData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->locale, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->locale);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAllDevicesOverviewExtendedData(struct soap *soap, const struct ns1__getAllDevicesOverviewExtendedData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAllDevicesOverviewExtendedData);
	if (soap_out_ns1__getAllDevicesOverviewExtendedData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAllDevicesOverviewExtendedData(struct soap *soap, const char *tag, int id, const struct ns1__getAllDevicesOverviewExtendedData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAllDevicesOverviewExtendedData), type))
		return soap->error;
	if (soap_out_std__string(soap, "locale", -1, &a->locale, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAllDevicesOverviewExtendedData * SOAP_FMAC4 soap_get_ns1__getAllDevicesOverviewExtendedData(struct soap *soap, struct ns1__getAllDevicesOverviewExtendedData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAllDevicesOverviewExtendedData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getAllDevicesOverviewExtendedData * SOAP_FMAC4 soap_in_ns1__getAllDevicesOverviewExtendedData(struct soap *soap, const char *tag, struct ns1__getAllDevicesOverviewExtendedData *a, const char *type)
{
	size_t soap_flag_locale = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAllDevicesOverviewExtendedData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAllDevicesOverviewExtendedData, sizeof(struct ns1__getAllDevicesOverviewExtendedData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getAllDevicesOverviewExtendedData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_locale && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "locale", &a->locale, "xsd:string"))
				{	soap_flag_locale--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAllDevicesOverviewExtendedData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAllDevicesOverviewExtendedData, 0, sizeof(struct ns1__getAllDevicesOverviewExtendedData), 0, soap_copy_ns1__getAllDevicesOverviewExtendedData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_locale > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__getAllDevicesOverviewExtendedData * SOAP_FMAC6 soap_new_ns1__getAllDevicesOverviewExtendedData(struct soap *soap, int n)
{	return soap_instantiate_ns1__getAllDevicesOverviewExtendedData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getAllDevicesOverviewExtendedData(struct soap *soap, struct ns1__getAllDevicesOverviewExtendedData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__getAllDevicesOverviewExtendedData * SOAP_FMAC4 soap_instantiate_ns1__getAllDevicesOverviewExtendedData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAllDevicesOverviewExtendedData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAllDevicesOverviewExtendedData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__getAllDevicesOverviewExtendedData;
		if (size)
			*size = sizeof(struct ns1__getAllDevicesOverviewExtendedData);
	}
	else
	{	cp->ptr = (void*)new struct ns1__getAllDevicesOverviewExtendedData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getAllDevicesOverviewExtendedData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getAllDevicesOverviewExtendedData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAllDevicesOverviewExtendedData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAllDevicesOverviewExtendedData %p -> %p\n", q, p));
	*(struct ns1__getAllDevicesOverviewExtendedData*)p = *(struct ns1__getAllDevicesOverviewExtendedData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAllDevicesOverviewExtendedDataResponse(struct soap *soap, struct ns1__getAllDevicesOverviewExtendedDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAllDevicesOverviewExtendedDataResponse(struct soap *soap, const struct ns1__getAllDevicesOverviewExtendedDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfDeviceStatesEx(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAllDevicesOverviewExtendedDataResponse(struct soap *soap, const struct ns1__getAllDevicesOverviewExtendedDataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAllDevicesOverviewExtendedDataResponse);
	if (soap_out_ns1__getAllDevicesOverviewExtendedDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAllDevicesOverviewExtendedDataResponse(struct soap *soap, const char *tag, int id, const struct ns1__getAllDevicesOverviewExtendedDataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAllDevicesOverviewExtendedDataResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfDeviceStatesEx(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAllDevicesOverviewExtendedDataResponse * SOAP_FMAC4 soap_get_ns1__getAllDevicesOverviewExtendedDataResponse(struct soap *soap, struct ns1__getAllDevicesOverviewExtendedDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAllDevicesOverviewExtendedDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getAllDevicesOverviewExtendedDataResponse * SOAP_FMAC4 soap_in_ns1__getAllDevicesOverviewExtendedDataResponse(struct soap *soap, const char *tag, struct ns1__getAllDevicesOverviewExtendedDataResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAllDevicesOverviewExtendedDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAllDevicesOverviewExtendedDataResponse, sizeof(struct ns1__getAllDevicesOverviewExtendedDataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getAllDevicesOverviewExtendedDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfDeviceStatesEx(soap, "return", &a->return_, "ns1:DeviceStateEx"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAllDevicesOverviewExtendedDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAllDevicesOverviewExtendedDataResponse, 0, sizeof(struct ns1__getAllDevicesOverviewExtendedDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__getAllDevicesOverviewExtendedDataResponse * SOAP_FMAC6 soap_new_ns1__getAllDevicesOverviewExtendedDataResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getAllDevicesOverviewExtendedDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getAllDevicesOverviewExtendedDataResponse(struct soap *soap, struct ns1__getAllDevicesOverviewExtendedDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__getAllDevicesOverviewExtendedDataResponse * SOAP_FMAC4 soap_instantiate_ns1__getAllDevicesOverviewExtendedDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAllDevicesOverviewExtendedDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAllDevicesOverviewExtendedDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__getAllDevicesOverviewExtendedDataResponse;
		if (size)
			*size = sizeof(struct ns1__getAllDevicesOverviewExtendedDataResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__getAllDevicesOverviewExtendedDataResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getAllDevicesOverviewExtendedDataResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getAllDevicesOverviewExtendedDataResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAllDevicesOverviewExtendedDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAllDevicesOverviewExtendedDataResponse %p -> %p\n", q, p));
	*(struct ns1__getAllDevicesOverviewExtendedDataResponse*)p = *(struct ns1__getAllDevicesOverviewExtendedDataResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAllDevicesOverviewData(struct soap *soap, struct ns1__getAllDevicesOverviewData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->locale);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAllDevicesOverviewData(struct soap *soap, const struct ns1__getAllDevicesOverviewData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->locale, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->locale);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAllDevicesOverviewData(struct soap *soap, const struct ns1__getAllDevicesOverviewData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAllDevicesOverviewData);
	if (soap_out_ns1__getAllDevicesOverviewData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAllDevicesOverviewData(struct soap *soap, const char *tag, int id, const struct ns1__getAllDevicesOverviewData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAllDevicesOverviewData), type))
		return soap->error;
	if (soap_out_std__string(soap, "locale", -1, &a->locale, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAllDevicesOverviewData * SOAP_FMAC4 soap_get_ns1__getAllDevicesOverviewData(struct soap *soap, struct ns1__getAllDevicesOverviewData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAllDevicesOverviewData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getAllDevicesOverviewData * SOAP_FMAC4 soap_in_ns1__getAllDevicesOverviewData(struct soap *soap, const char *tag, struct ns1__getAllDevicesOverviewData *a, const char *type)
{
	size_t soap_flag_locale = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAllDevicesOverviewData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAllDevicesOverviewData, sizeof(struct ns1__getAllDevicesOverviewData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getAllDevicesOverviewData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_locale && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "locale", &a->locale, "xsd:string"))
				{	soap_flag_locale--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAllDevicesOverviewData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAllDevicesOverviewData, 0, sizeof(struct ns1__getAllDevicesOverviewData), 0, soap_copy_ns1__getAllDevicesOverviewData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_locale > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__getAllDevicesOverviewData * SOAP_FMAC6 soap_new_ns1__getAllDevicesOverviewData(struct soap *soap, int n)
{	return soap_instantiate_ns1__getAllDevicesOverviewData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getAllDevicesOverviewData(struct soap *soap, struct ns1__getAllDevicesOverviewData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__getAllDevicesOverviewData * SOAP_FMAC4 soap_instantiate_ns1__getAllDevicesOverviewData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAllDevicesOverviewData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAllDevicesOverviewData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__getAllDevicesOverviewData;
		if (size)
			*size = sizeof(struct ns1__getAllDevicesOverviewData);
	}
	else
	{	cp->ptr = (void*)new struct ns1__getAllDevicesOverviewData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getAllDevicesOverviewData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getAllDevicesOverviewData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAllDevicesOverviewData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAllDevicesOverviewData %p -> %p\n", q, p));
	*(struct ns1__getAllDevicesOverviewData*)p = *(struct ns1__getAllDevicesOverviewData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAllDevicesOverviewDataResponse(struct soap *soap, struct ns1__getAllDevicesOverviewDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAllDevicesOverviewDataResponse(struct soap *soap, const struct ns1__getAllDevicesOverviewDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfDeviceStates(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAllDevicesOverviewDataResponse(struct soap *soap, const struct ns1__getAllDevicesOverviewDataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAllDevicesOverviewDataResponse);
	if (soap_out_ns1__getAllDevicesOverviewDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAllDevicesOverviewDataResponse(struct soap *soap, const char *tag, int id, const struct ns1__getAllDevicesOverviewDataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAllDevicesOverviewDataResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfDeviceStates(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAllDevicesOverviewDataResponse * SOAP_FMAC4 soap_get_ns1__getAllDevicesOverviewDataResponse(struct soap *soap, struct ns1__getAllDevicesOverviewDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAllDevicesOverviewDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getAllDevicesOverviewDataResponse * SOAP_FMAC4 soap_in_ns1__getAllDevicesOverviewDataResponse(struct soap *soap, const char *tag, struct ns1__getAllDevicesOverviewDataResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAllDevicesOverviewDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAllDevicesOverviewDataResponse, sizeof(struct ns1__getAllDevicesOverviewDataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getAllDevicesOverviewDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfDeviceStates(soap, "return", &a->return_, "ns1:DeviceState"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAllDevicesOverviewDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAllDevicesOverviewDataResponse, 0, sizeof(struct ns1__getAllDevicesOverviewDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__getAllDevicesOverviewDataResponse * SOAP_FMAC6 soap_new_ns1__getAllDevicesOverviewDataResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getAllDevicesOverviewDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getAllDevicesOverviewDataResponse(struct soap *soap, struct ns1__getAllDevicesOverviewDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__getAllDevicesOverviewDataResponse * SOAP_FMAC4 soap_instantiate_ns1__getAllDevicesOverviewDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAllDevicesOverviewDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAllDevicesOverviewDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__getAllDevicesOverviewDataResponse;
		if (size)
			*size = sizeof(struct ns1__getAllDevicesOverviewDataResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__getAllDevicesOverviewDataResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getAllDevicesOverviewDataResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getAllDevicesOverviewDataResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAllDevicesOverviewDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAllDevicesOverviewDataResponse %p -> %p\n", q, p));
	*(struct ns1__getAllDevicesOverviewDataResponse*)p = *(struct ns1__getAllDevicesOverviewDataResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDeviceOverviewExtendedData(struct soap *soap, struct ns1__getDeviceOverviewExtendedData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->deviceID);
	soap_default_std__string(soap, &a->locale);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDeviceOverviewExtendedData(struct soap *soap, const struct ns1__getDeviceOverviewExtendedData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->deviceID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->deviceID);
	soap_embedded(soap, &a->locale, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->locale);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDeviceOverviewExtendedData(struct soap *soap, const struct ns1__getDeviceOverviewExtendedData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDeviceOverviewExtendedData);
	if (soap_out_ns1__getDeviceOverviewExtendedData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDeviceOverviewExtendedData(struct soap *soap, const char *tag, int id, const struct ns1__getDeviceOverviewExtendedData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDeviceOverviewExtendedData), type))
		return soap->error;
	if (soap_out_std__string(soap, "deviceID", -1, &a->deviceID, ""))
		return soap->error;
	if (soap_out_std__string(soap, "locale", -1, &a->locale, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDeviceOverviewExtendedData * SOAP_FMAC4 soap_get_ns1__getDeviceOverviewExtendedData(struct soap *soap, struct ns1__getDeviceOverviewExtendedData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDeviceOverviewExtendedData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getDeviceOverviewExtendedData * SOAP_FMAC4 soap_in_ns1__getDeviceOverviewExtendedData(struct soap *soap, const char *tag, struct ns1__getDeviceOverviewExtendedData *a, const char *type)
{
	size_t soap_flag_deviceID = 1;
	size_t soap_flag_locale = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDeviceOverviewExtendedData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDeviceOverviewExtendedData, sizeof(struct ns1__getDeviceOverviewExtendedData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getDeviceOverviewExtendedData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "deviceID", &a->deviceID, "xsd:string"))
				{	soap_flag_deviceID--;
					continue;
				}
			if (soap_flag_locale && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "locale", &a->locale, "xsd:string"))
				{	soap_flag_locale--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDeviceOverviewExtendedData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDeviceOverviewExtendedData, 0, sizeof(struct ns1__getDeviceOverviewExtendedData), 0, soap_copy_ns1__getDeviceOverviewExtendedData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deviceID > 0 || soap_flag_locale > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__getDeviceOverviewExtendedData * SOAP_FMAC6 soap_new_ns1__getDeviceOverviewExtendedData(struct soap *soap, int n)
{	return soap_instantiate_ns1__getDeviceOverviewExtendedData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getDeviceOverviewExtendedData(struct soap *soap, struct ns1__getDeviceOverviewExtendedData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__getDeviceOverviewExtendedData * SOAP_FMAC4 soap_instantiate_ns1__getDeviceOverviewExtendedData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDeviceOverviewExtendedData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDeviceOverviewExtendedData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__getDeviceOverviewExtendedData;
		if (size)
			*size = sizeof(struct ns1__getDeviceOverviewExtendedData);
	}
	else
	{	cp->ptr = (void*)new struct ns1__getDeviceOverviewExtendedData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getDeviceOverviewExtendedData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getDeviceOverviewExtendedData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDeviceOverviewExtendedData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDeviceOverviewExtendedData %p -> %p\n", q, p));
	*(struct ns1__getDeviceOverviewExtendedData*)p = *(struct ns1__getDeviceOverviewExtendedData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDeviceOverviewExtendedDataResponse(struct soap *soap, struct ns1__getDeviceOverviewExtendedDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDeviceOverviewExtendedDataResponse(struct soap *soap, const struct ns1__getDeviceOverviewExtendedDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__DeviceStateEx(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDeviceOverviewExtendedDataResponse(struct soap *soap, const struct ns1__getDeviceOverviewExtendedDataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDeviceOverviewExtendedDataResponse);
	if (soap_out_ns1__getDeviceOverviewExtendedDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDeviceOverviewExtendedDataResponse(struct soap *soap, const char *tag, int id, const struct ns1__getDeviceOverviewExtendedDataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDeviceOverviewExtendedDataResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__DeviceStateEx(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDeviceOverviewExtendedDataResponse * SOAP_FMAC4 soap_get_ns1__getDeviceOverviewExtendedDataResponse(struct soap *soap, struct ns1__getDeviceOverviewExtendedDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDeviceOverviewExtendedDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getDeviceOverviewExtendedDataResponse * SOAP_FMAC4 soap_in_ns1__getDeviceOverviewExtendedDataResponse(struct soap *soap, const char *tag, struct ns1__getDeviceOverviewExtendedDataResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDeviceOverviewExtendedDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDeviceOverviewExtendedDataResponse, sizeof(struct ns1__getDeviceOverviewExtendedDataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDeviceOverviewExtendedDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__DeviceStateEx(soap, "return", &a->return_, "ns1:DeviceStateEx"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDeviceOverviewExtendedDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDeviceOverviewExtendedDataResponse, 0, sizeof(struct ns1__getDeviceOverviewExtendedDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__getDeviceOverviewExtendedDataResponse * SOAP_FMAC6 soap_new_ns1__getDeviceOverviewExtendedDataResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getDeviceOverviewExtendedDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getDeviceOverviewExtendedDataResponse(struct soap *soap, struct ns1__getDeviceOverviewExtendedDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__getDeviceOverviewExtendedDataResponse * SOAP_FMAC4 soap_instantiate_ns1__getDeviceOverviewExtendedDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDeviceOverviewExtendedDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDeviceOverviewExtendedDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__getDeviceOverviewExtendedDataResponse;
		if (size)
			*size = sizeof(struct ns1__getDeviceOverviewExtendedDataResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__getDeviceOverviewExtendedDataResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getDeviceOverviewExtendedDataResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getDeviceOverviewExtendedDataResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDeviceOverviewExtendedDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDeviceOverviewExtendedDataResponse %p -> %p\n", q, p));
	*(struct ns1__getDeviceOverviewExtendedDataResponse*)p = *(struct ns1__getDeviceOverviewExtendedDataResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDeviceOverviewData(struct soap *soap, struct ns1__getDeviceOverviewData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->deviceID);
	soap_default_std__string(soap, &a->locale);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDeviceOverviewData(struct soap *soap, const struct ns1__getDeviceOverviewData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->deviceID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->deviceID);
	soap_embedded(soap, &a->locale, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->locale);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDeviceOverviewData(struct soap *soap, const struct ns1__getDeviceOverviewData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDeviceOverviewData);
	if (soap_out_ns1__getDeviceOverviewData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDeviceOverviewData(struct soap *soap, const char *tag, int id, const struct ns1__getDeviceOverviewData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDeviceOverviewData), type))
		return soap->error;
	if (soap_out_std__string(soap, "deviceID", -1, &a->deviceID, ""))
		return soap->error;
	if (soap_out_std__string(soap, "locale", -1, &a->locale, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDeviceOverviewData * SOAP_FMAC4 soap_get_ns1__getDeviceOverviewData(struct soap *soap, struct ns1__getDeviceOverviewData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDeviceOverviewData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getDeviceOverviewData * SOAP_FMAC4 soap_in_ns1__getDeviceOverviewData(struct soap *soap, const char *tag, struct ns1__getDeviceOverviewData *a, const char *type)
{
	size_t soap_flag_deviceID = 1;
	size_t soap_flag_locale = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDeviceOverviewData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDeviceOverviewData, sizeof(struct ns1__getDeviceOverviewData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__getDeviceOverviewData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_deviceID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "deviceID", &a->deviceID, "xsd:string"))
				{	soap_flag_deviceID--;
					continue;
				}
			if (soap_flag_locale && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "locale", &a->locale, "xsd:string"))
				{	soap_flag_locale--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDeviceOverviewData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDeviceOverviewData, 0, sizeof(struct ns1__getDeviceOverviewData), 0, soap_copy_ns1__getDeviceOverviewData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_deviceID > 0 || soap_flag_locale > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__getDeviceOverviewData * SOAP_FMAC6 soap_new_ns1__getDeviceOverviewData(struct soap *soap, int n)
{	return soap_instantiate_ns1__getDeviceOverviewData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getDeviceOverviewData(struct soap *soap, struct ns1__getDeviceOverviewData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__getDeviceOverviewData * SOAP_FMAC4 soap_instantiate_ns1__getDeviceOverviewData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDeviceOverviewData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDeviceOverviewData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__getDeviceOverviewData;
		if (size)
			*size = sizeof(struct ns1__getDeviceOverviewData);
	}
	else
	{	cp->ptr = (void*)new struct ns1__getDeviceOverviewData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getDeviceOverviewData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getDeviceOverviewData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDeviceOverviewData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDeviceOverviewData %p -> %p\n", q, p));
	*(struct ns1__getDeviceOverviewData*)p = *(struct ns1__getDeviceOverviewData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getDeviceOverviewDataResponse(struct soap *soap, struct ns1__getDeviceOverviewDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getDeviceOverviewDataResponse(struct soap *soap, const struct ns1__getDeviceOverviewDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__DeviceState(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getDeviceOverviewDataResponse(struct soap *soap, const struct ns1__getDeviceOverviewDataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getDeviceOverviewDataResponse);
	if (soap_out_ns1__getDeviceOverviewDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getDeviceOverviewDataResponse(struct soap *soap, const char *tag, int id, const struct ns1__getDeviceOverviewDataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getDeviceOverviewDataResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__DeviceState(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getDeviceOverviewDataResponse * SOAP_FMAC4 soap_get_ns1__getDeviceOverviewDataResponse(struct soap *soap, struct ns1__getDeviceOverviewDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getDeviceOverviewDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getDeviceOverviewDataResponse * SOAP_FMAC4 soap_in_ns1__getDeviceOverviewDataResponse(struct soap *soap, const char *tag, struct ns1__getDeviceOverviewDataResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getDeviceOverviewDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getDeviceOverviewDataResponse, sizeof(struct ns1__getDeviceOverviewDataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getDeviceOverviewDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__DeviceState(soap, "return", &a->return_, "ns1:DeviceState"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getDeviceOverviewDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getDeviceOverviewDataResponse, 0, sizeof(struct ns1__getDeviceOverviewDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__getDeviceOverviewDataResponse * SOAP_FMAC6 soap_new_ns1__getDeviceOverviewDataResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getDeviceOverviewDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getDeviceOverviewDataResponse(struct soap *soap, struct ns1__getDeviceOverviewDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__getDeviceOverviewDataResponse * SOAP_FMAC4 soap_instantiate_ns1__getDeviceOverviewDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getDeviceOverviewDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getDeviceOverviewDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__getDeviceOverviewDataResponse;
		if (size)
			*size = sizeof(struct ns1__getDeviceOverviewDataResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__getDeviceOverviewDataResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getDeviceOverviewDataResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getDeviceOverviewDataResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getDeviceOverviewDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getDeviceOverviewDataResponse %p -> %p\n", q, p));
	*(struct ns1__getDeviceOverviewDataResponse*)p = *(struct ns1__getDeviceOverviewDataResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAvailableDevicesIDs(struct soap *soap, struct ns1__getAvailableDevicesIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAvailableDevicesIDs(struct soap *soap, const struct ns1__getAvailableDevicesIDs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAvailableDevicesIDs(struct soap *soap, const struct ns1__getAvailableDevicesIDs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAvailableDevicesIDs);
	if (soap_out_ns1__getAvailableDevicesIDs(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAvailableDevicesIDs(struct soap *soap, const char *tag, int id, const struct ns1__getAvailableDevicesIDs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAvailableDevicesIDs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAvailableDevicesIDs * SOAP_FMAC4 soap_get_ns1__getAvailableDevicesIDs(struct soap *soap, struct ns1__getAvailableDevicesIDs *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAvailableDevicesIDs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getAvailableDevicesIDs * SOAP_FMAC4 soap_in_ns1__getAvailableDevicesIDs(struct soap *soap, const char *tag, struct ns1__getAvailableDevicesIDs *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAvailableDevicesIDs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAvailableDevicesIDs, sizeof(struct ns1__getAvailableDevicesIDs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getAvailableDevicesIDs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAvailableDevicesIDs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAvailableDevicesIDs, 0, sizeof(struct ns1__getAvailableDevicesIDs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__getAvailableDevicesIDs * SOAP_FMAC6 soap_new_ns1__getAvailableDevicesIDs(struct soap *soap, int n)
{	return soap_instantiate_ns1__getAvailableDevicesIDs(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getAvailableDevicesIDs(struct soap *soap, struct ns1__getAvailableDevicesIDs *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__getAvailableDevicesIDs * SOAP_FMAC4 soap_instantiate_ns1__getAvailableDevicesIDs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAvailableDevicesIDs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAvailableDevicesIDs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__getAvailableDevicesIDs;
		if (size)
			*size = sizeof(struct ns1__getAvailableDevicesIDs);
	}
	else
	{	cp->ptr = (void*)new struct ns1__getAvailableDevicesIDs[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getAvailableDevicesIDs);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getAvailableDevicesIDs*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAvailableDevicesIDs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAvailableDevicesIDs %p -> %p\n", q, p));
	*(struct ns1__getAvailableDevicesIDs*)p = *(struct ns1__getAvailableDevicesIDs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getAvailableDevicesIDsResponse(struct soap *soap, struct ns1__getAvailableDevicesIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->return_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getAvailableDevicesIDsResponse(struct soap *soap, const struct ns1__getAvailableDevicesIDsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfString(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getAvailableDevicesIDsResponse(struct soap *soap, const struct ns1__getAvailableDevicesIDsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getAvailableDevicesIDsResponse);
	if (soap_out_ns1__getAvailableDevicesIDsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getAvailableDevicesIDsResponse(struct soap *soap, const char *tag, int id, const struct ns1__getAvailableDevicesIDsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getAvailableDevicesIDsResponse), type))
		return soap->error;
	if (soap_out_PointerToArrayOfString(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getAvailableDevicesIDsResponse * SOAP_FMAC4 soap_get_ns1__getAvailableDevicesIDsResponse(struct soap *soap, struct ns1__getAvailableDevicesIDsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getAvailableDevicesIDsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getAvailableDevicesIDsResponse * SOAP_FMAC4 soap_in_ns1__getAvailableDevicesIDsResponse(struct soap *soap, const char *tag, struct ns1__getAvailableDevicesIDsResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getAvailableDevicesIDsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getAvailableDevicesIDsResponse, sizeof(struct ns1__getAvailableDevicesIDsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getAvailableDevicesIDsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfString(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getAvailableDevicesIDsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getAvailableDevicesIDsResponse, 0, sizeof(struct ns1__getAvailableDevicesIDsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__getAvailableDevicesIDsResponse * SOAP_FMAC6 soap_new_ns1__getAvailableDevicesIDsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getAvailableDevicesIDsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getAvailableDevicesIDsResponse(struct soap *soap, struct ns1__getAvailableDevicesIDsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__getAvailableDevicesIDsResponse * SOAP_FMAC4 soap_instantiate_ns1__getAvailableDevicesIDsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getAvailableDevicesIDsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getAvailableDevicesIDsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__getAvailableDevicesIDsResponse;
		if (size)
			*size = sizeof(struct ns1__getAvailableDevicesIDsResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__getAvailableDevicesIDsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getAvailableDevicesIDsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getAvailableDevicesIDsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getAvailableDevicesIDsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getAvailableDevicesIDsResponse %p -> %p\n", q, p));
	*(struct ns1__getAvailableDevicesIDsResponse*)p = *(struct ns1__getAvailableDevicesIDsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getServerTimestamp(struct soap *soap, struct ns1__getServerTimestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getServerTimestamp(struct soap *soap, const struct ns1__getServerTimestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getServerTimestamp(struct soap *soap, const struct ns1__getServerTimestamp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getServerTimestamp);
	if (soap_out_ns1__getServerTimestamp(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getServerTimestamp(struct soap *soap, const char *tag, int id, const struct ns1__getServerTimestamp *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getServerTimestamp), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getServerTimestamp * SOAP_FMAC4 soap_get_ns1__getServerTimestamp(struct soap *soap, struct ns1__getServerTimestamp *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getServerTimestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getServerTimestamp * SOAP_FMAC4 soap_in_ns1__getServerTimestamp(struct soap *soap, const char *tag, struct ns1__getServerTimestamp *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getServerTimestamp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getServerTimestamp, sizeof(struct ns1__getServerTimestamp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getServerTimestamp(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getServerTimestamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getServerTimestamp, 0, sizeof(struct ns1__getServerTimestamp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__getServerTimestamp * SOAP_FMAC6 soap_new_ns1__getServerTimestamp(struct soap *soap, int n)
{	return soap_instantiate_ns1__getServerTimestamp(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getServerTimestamp(struct soap *soap, struct ns1__getServerTimestamp *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__getServerTimestamp * SOAP_FMAC4 soap_instantiate_ns1__getServerTimestamp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getServerTimestamp(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getServerTimestamp, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__getServerTimestamp;
		if (size)
			*size = sizeof(struct ns1__getServerTimestamp);
	}
	else
	{	cp->ptr = (void*)new struct ns1__getServerTimestamp[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getServerTimestamp);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getServerTimestamp*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getServerTimestamp(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getServerTimestamp %p -> %p\n", q, p));
	*(struct ns1__getServerTimestamp*)p = *(struct ns1__getServerTimestamp*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__getServerTimestampResponse(struct soap *soap, struct ns1__getServerTimestampResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__getServerTimestampResponse(struct soap *soap, const struct ns1__getServerTimestampResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__getServerTimestampResponse(struct soap *soap, const struct ns1__getServerTimestampResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__getServerTimestampResponse);
	if (soap_out_ns1__getServerTimestampResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getServerTimestampResponse(struct soap *soap, const char *tag, int id, const struct ns1__getServerTimestampResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getServerTimestampResponse), type))
		return soap->error;
	if (soap_out_time(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__getServerTimestampResponse * SOAP_FMAC4 soap_get_ns1__getServerTimestampResponse(struct soap *soap, struct ns1__getServerTimestampResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getServerTimestampResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__getServerTimestampResponse * SOAP_FMAC4 soap_in_ns1__getServerTimestampResponse(struct soap *soap, const char *tag, struct ns1__getServerTimestampResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__getServerTimestampResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getServerTimestampResponse, sizeof(struct ns1__getServerTimestampResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__getServerTimestampResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "return", &a->return_, "xsd:dateTime"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__getServerTimestampResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getServerTimestampResponse, 0, sizeof(struct ns1__getServerTimestampResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__getServerTimestampResponse * SOAP_FMAC6 soap_new_ns1__getServerTimestampResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getServerTimestampResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getServerTimestampResponse(struct soap *soap, struct ns1__getServerTimestampResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__getServerTimestampResponse * SOAP_FMAC4 soap_instantiate_ns1__getServerTimestampResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getServerTimestampResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getServerTimestampResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__getServerTimestampResponse;
		if (size)
			*size = sizeof(struct ns1__getServerTimestampResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__getServerTimestampResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__getServerTimestampResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__getServerTimestampResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getServerTimestampResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__getServerTimestampResponse %p -> %p\n", q, p));
	*(struct ns1__getServerTimestampResponse*)p = *(struct ns1__getServerTimestampResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__echo(struct soap *soap, struct ns1__echo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->str);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__echo(struct soap *soap, const struct ns1__echo *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->str, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->str);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__echo(struct soap *soap, const struct ns1__echo *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__echo);
	if (soap_out_ns1__echo(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__echo(struct soap *soap, const char *tag, int id, const struct ns1__echo *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__echo), type))
		return soap->error;
	if (soap_out_std__string(soap, "str", -1, &a->str, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__echo * SOAP_FMAC4 soap_get_ns1__echo(struct soap *soap, struct ns1__echo *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__echo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__echo * SOAP_FMAC4 soap_in_ns1__echo(struct soap *soap, const char *tag, struct ns1__echo *a, const char *type)
{
	size_t soap_flag_str = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__echo *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__echo, sizeof(struct ns1__echo), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__echo(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_str && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "str", &a->str, "xsd:string"))
				{	soap_flag_str--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__echo *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__echo, 0, sizeof(struct ns1__echo), 0, soap_copy_ns1__echo);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_str > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__echo * SOAP_FMAC6 soap_new_ns1__echo(struct soap *soap, int n)
{	return soap_instantiate_ns1__echo(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__echo(struct soap *soap, struct ns1__echo *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__echo * SOAP_FMAC4 soap_instantiate_ns1__echo(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__echo(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__echo, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__echo;
		if (size)
			*size = sizeof(struct ns1__echo);
	}
	else
	{	cp->ptr = (void*)new struct ns1__echo[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__echo);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__echo*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__echo(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__echo %p -> %p\n", q, p));
	*(struct ns1__echo*)p = *(struct ns1__echo*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__echoResponse(struct soap *soap, struct ns1__echoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->return_);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__echoResponse(struct soap *soap, const struct ns1__echoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->return_, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->return_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__echoResponse(struct soap *soap, const struct ns1__echoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__echoResponse);
	if (soap_out_ns1__echoResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__echoResponse(struct soap *soap, const char *tag, int id, const struct ns1__echoResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__echoResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "return", -1, &a->return_, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__echoResponse * SOAP_FMAC4 soap_get_ns1__echoResponse(struct soap *soap, struct ns1__echoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__echoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct ns1__echoResponse * SOAP_FMAC4 soap_in_ns1__echoResponse(struct soap *soap, const char *tag, struct ns1__echoResponse *a, const char *type)
{
	size_t soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__echoResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__echoResponse, sizeof(struct ns1__echoResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_ns1__echoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__echoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__echoResponse, 0, sizeof(struct ns1__echoResponse), 0, soap_copy_ns1__echoResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_ > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct ns1__echoResponse * SOAP_FMAC6 soap_new_ns1__echoResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__echoResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__echoResponse(struct soap *soap, struct ns1__echoResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct ns1__echoResponse * SOAP_FMAC4 soap_instantiate_ns1__echoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__echoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__echoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct ns1__echoResponse;
		if (size)
			*size = sizeof(struct ns1__echoResponse);
	}
	else
	{	cp->ptr = (void*)new struct ns1__echoResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct ns1__echoResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct ns1__echoResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__echoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns1__echoResponse %p -> %p\n", q, p));
	*(struct ns1__echoResponse*)p = *(struct ns1__echoResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfDeviceStateVariable(struct soap *soap, ArrayOfDeviceStateVariable *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfDeviceStateVariable(struct soap *soap, ArrayOfDeviceStateVariable *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfDeviceStateVariable);
	if (soap_out_PointerToArrayOfDeviceStateVariable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfDeviceStateVariable(struct soap *soap, const char *tag, int id, ArrayOfDeviceStateVariable *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfDeviceStateVariable);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfDeviceStateVariable ** SOAP_FMAC4 soap_get_PointerToArrayOfDeviceStateVariable(struct soap *soap, ArrayOfDeviceStateVariable **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfDeviceStateVariable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ArrayOfDeviceStateVariable ** SOAP_FMAC4 soap_in_PointerToArrayOfDeviceStateVariable(struct soap *soap, const char *tag, ArrayOfDeviceStateVariable **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfDeviceStateVariable **)soap_malloc(soap, sizeof(ArrayOfDeviceStateVariable *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfDeviceStateVariable *)soap_instantiate_ArrayOfDeviceStateVariable(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfDeviceStateVariable ** p = (ArrayOfDeviceStateVariable **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfDeviceStateVariable, sizeof(ArrayOfDeviceStateVariable), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfMessageEvent(struct soap *soap, ArrayOfMessageEvent *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfMessageEvent(struct soap *soap, ArrayOfMessageEvent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfMessageEvent);
	if (soap_out_PointerToArrayOfMessageEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfMessageEvent(struct soap *soap, const char *tag, int id, ArrayOfMessageEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfMessageEvent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfMessageEvent ** SOAP_FMAC4 soap_get_PointerToArrayOfMessageEvent(struct soap *soap, ArrayOfMessageEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfMessageEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ArrayOfMessageEvent ** SOAP_FMAC4 soap_in_PointerToArrayOfMessageEvent(struct soap *soap, const char *tag, ArrayOfMessageEvent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfMessageEvent **)soap_malloc(soap, sizeof(ArrayOfMessageEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfMessageEvent *)soap_instantiate_ArrayOfMessageEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfMessageEvent ** p = (ArrayOfMessageEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfMessageEvent, sizeof(ArrayOfMessageEvent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfAnyType(struct soap *soap, ArrayOfAnyType *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfAnyType(struct soap *soap, ArrayOfAnyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfAnyType);
	if (soap_out_PointerToArrayOfAnyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfAnyType(struct soap *soap, const char *tag, int id, ArrayOfAnyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfAnyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfAnyType ** SOAP_FMAC4 soap_get_PointerToArrayOfAnyType(struct soap *soap, ArrayOfAnyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfAnyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ArrayOfAnyType ** SOAP_FMAC4 soap_in_PointerToArrayOfAnyType(struct soap *soap, const char *tag, ArrayOfAnyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfAnyType **)soap_malloc(soap, sizeof(ArrayOfAnyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfAnyType *)soap_instantiate_ArrayOfAnyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfAnyType ** p = (ArrayOfAnyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfAnyType, sizeof(ArrayOfAnyType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfDeviceStatesEx(struct soap *soap, ArrayOfDeviceStatesEx *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfDeviceStatesEx(struct soap *soap, ArrayOfDeviceStatesEx *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfDeviceStatesEx);
	if (soap_out_PointerToArrayOfDeviceStatesEx(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfDeviceStatesEx(struct soap *soap, const char *tag, int id, ArrayOfDeviceStatesEx *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfDeviceStatesEx);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfDeviceStatesEx ** SOAP_FMAC4 soap_get_PointerToArrayOfDeviceStatesEx(struct soap *soap, ArrayOfDeviceStatesEx **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfDeviceStatesEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ArrayOfDeviceStatesEx ** SOAP_FMAC4 soap_in_PointerToArrayOfDeviceStatesEx(struct soap *soap, const char *tag, ArrayOfDeviceStatesEx **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfDeviceStatesEx **)soap_malloc(soap, sizeof(ArrayOfDeviceStatesEx *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfDeviceStatesEx *)soap_instantiate_ArrayOfDeviceStatesEx(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfDeviceStatesEx ** p = (ArrayOfDeviceStatesEx **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfDeviceStatesEx, sizeof(ArrayOfDeviceStatesEx), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfDeviceStates(struct soap *soap, ArrayOfDeviceStates *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfDeviceStates(struct soap *soap, ArrayOfDeviceStates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfDeviceStates);
	if (soap_out_PointerToArrayOfDeviceStates(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfDeviceStates(struct soap *soap, const char *tag, int id, ArrayOfDeviceStates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfDeviceStates);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfDeviceStates ** SOAP_FMAC4 soap_get_PointerToArrayOfDeviceStates(struct soap *soap, ArrayOfDeviceStates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfDeviceStates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ArrayOfDeviceStates ** SOAP_FMAC4 soap_in_PointerToArrayOfDeviceStates(struct soap *soap, const char *tag, ArrayOfDeviceStates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfDeviceStates **)soap_malloc(soap, sizeof(ArrayOfDeviceStates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfDeviceStates *)soap_instantiate_ArrayOfDeviceStates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfDeviceStates ** p = (ArrayOfDeviceStates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfDeviceStates, sizeof(ArrayOfDeviceStates), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__DeviceStateEx(struct soap *soap, ns1__DeviceStateEx **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__DeviceStateEx))
		soap_serialize_PointerTons1__DeviceStateEx(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__DeviceStateEx(struct soap *soap, ns1__DeviceStateEx **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__DeviceStateEx);
	if (soap_out_PointerToPointerTons1__DeviceStateEx(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__DeviceStateEx(struct soap *soap, const char *tag, int id, ns1__DeviceStateEx **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__DeviceStateEx);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__DeviceStateEx(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__DeviceStateEx *** SOAP_FMAC4 soap_get_PointerToPointerTons1__DeviceStateEx(struct soap *soap, ns1__DeviceStateEx ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__DeviceStateEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__DeviceStateEx *** SOAP_FMAC4 soap_in_PointerToPointerTons1__DeviceStateEx(struct soap *soap, const char *tag, ns1__DeviceStateEx ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DeviceStateEx ***)soap_malloc(soap, sizeof(ns1__DeviceStateEx **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__DeviceStateEx(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__DeviceStateEx ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__DeviceStateEx, sizeof(ns1__DeviceStateEx *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DeviceStateEx(struct soap *soap, ns1__DeviceStateEx *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DeviceStateEx))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DeviceStateEx(struct soap *soap, ns1__DeviceStateEx *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__DeviceStateEx);
	if (soap_out_PointerTons1__DeviceStateEx(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DeviceStateEx(struct soap *soap, const char *tag, int id, ns1__DeviceStateEx *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DeviceStateEx);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__DeviceStateEx ** SOAP_FMAC4 soap_get_PointerTons1__DeviceStateEx(struct soap *soap, ns1__DeviceStateEx **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DeviceStateEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__DeviceStateEx ** SOAP_FMAC4 soap_in_PointerTons1__DeviceStateEx(struct soap *soap, const char *tag, ns1__DeviceStateEx **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DeviceStateEx **)soap_malloc(soap, sizeof(ns1__DeviceStateEx *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DeviceStateEx *)soap_instantiate_ns1__DeviceStateEx(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__DeviceStateEx ** p = (ns1__DeviceStateEx **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DeviceStateEx, sizeof(ns1__DeviceStateEx), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerToxsd__anyType(struct soap *soap, xsd__anyType **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerToxsd__anyType))
		soap_serialize_PointerToxsd__anyType(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerToxsd__anyType(struct soap *soap, xsd__anyType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerToxsd__anyType);
	if (soap_out_PointerToPointerToxsd__anyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerToxsd__anyType(struct soap *soap, const char *tag, int id, xsd__anyType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerToxsd__anyType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerToxsd__anyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 xsd__anyType *** SOAP_FMAC4 soap_get_PointerToPointerToxsd__anyType(struct soap *soap, xsd__anyType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerToxsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 xsd__anyType *** SOAP_FMAC4 soap_in_PointerToPointerToxsd__anyType(struct soap *soap, const char *tag, xsd__anyType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__anyType ***)soap_malloc(soap, sizeof(xsd__anyType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerToxsd__anyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (xsd__anyType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerToxsd__anyType, sizeof(xsd__anyType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyType))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyType(struct soap *soap, xsd__anyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyType);
	if (soap_out_PointerToxsd__anyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyType(struct soap *soap, const char *tag, int id, xsd__anyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_get_PointerToxsd__anyType(struct soap *soap, xsd__anyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 xsd__anyType ** SOAP_FMAC4 soap_in_PointerToxsd__anyType(struct soap *soap, const char *tag, xsd__anyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (xsd__anyType **)soap_malloc(soap, sizeof(xsd__anyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (xsd__anyType *)soap_instantiate_xsd__anyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	xsd__anyType ** p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__dateTime, sizeof(xsd__dateTime), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__int, sizeof(xsd__int), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__long, sizeof(xsd__long), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__string, sizeof(xsd__string), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DeviceState, sizeof(ns1__DeviceState), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MessageEvent, sizeof(ns1__MessageEvent), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DeviceStateVariable, sizeof(ns1__DeviceStateVariable), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DeviceStateEx, sizeof(ns1__DeviceStateEx), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfDeviceStates, sizeof(ArrayOfDeviceStates), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfMessageEvent, sizeof(ArrayOfMessageEvent), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfDeviceStateVariable, sizeof(ArrayOfDeviceStateVariable), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfString, sizeof(ArrayOfString), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfAnyType, sizeof(ArrayOfAnyType), 0);
		}
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (xsd__anyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfDeviceStatesEx, sizeof(ArrayOfDeviceStatesEx), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__DeviceStateVariable(struct soap *soap, ns1__DeviceStateVariable **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__DeviceStateVariable))
		soap_serialize_PointerTons1__DeviceStateVariable(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__DeviceStateVariable(struct soap *soap, ns1__DeviceStateVariable **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__DeviceStateVariable);
	if (soap_out_PointerToPointerTons1__DeviceStateVariable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__DeviceStateVariable(struct soap *soap, const char *tag, int id, ns1__DeviceStateVariable **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__DeviceStateVariable);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__DeviceStateVariable(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__DeviceStateVariable *** SOAP_FMAC4 soap_get_PointerToPointerTons1__DeviceStateVariable(struct soap *soap, ns1__DeviceStateVariable ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__DeviceStateVariable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__DeviceStateVariable *** SOAP_FMAC4 soap_in_PointerToPointerTons1__DeviceStateVariable(struct soap *soap, const char *tag, ns1__DeviceStateVariable ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DeviceStateVariable ***)soap_malloc(soap, sizeof(ns1__DeviceStateVariable **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__DeviceStateVariable(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__DeviceStateVariable ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__DeviceStateVariable, sizeof(ns1__DeviceStateVariable *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DeviceStateVariable(struct soap *soap, ns1__DeviceStateVariable *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DeviceStateVariable))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DeviceStateVariable(struct soap *soap, ns1__DeviceStateVariable *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__DeviceStateVariable);
	if (soap_out_PointerTons1__DeviceStateVariable(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DeviceStateVariable(struct soap *soap, const char *tag, int id, ns1__DeviceStateVariable *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DeviceStateVariable);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__DeviceStateVariable ** SOAP_FMAC4 soap_get_PointerTons1__DeviceStateVariable(struct soap *soap, ns1__DeviceStateVariable **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DeviceStateVariable(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__DeviceStateVariable ** SOAP_FMAC4 soap_in_PointerTons1__DeviceStateVariable(struct soap *soap, const char *tag, ns1__DeviceStateVariable **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DeviceStateVariable **)soap_malloc(soap, sizeof(ns1__DeviceStateVariable *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DeviceStateVariable *)soap_instantiate_ns1__DeviceStateVariable(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__DeviceStateVariable ** p = (ns1__DeviceStateVariable **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DeviceStateVariable, sizeof(ns1__DeviceStateVariable), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__MessageEvent(struct soap *soap, ns1__MessageEvent **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__MessageEvent))
		soap_serialize_PointerTons1__MessageEvent(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__MessageEvent(struct soap *soap, ns1__MessageEvent **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__MessageEvent);
	if (soap_out_PointerToPointerTons1__MessageEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__MessageEvent(struct soap *soap, const char *tag, int id, ns1__MessageEvent **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__MessageEvent);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__MessageEvent(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__MessageEvent *** SOAP_FMAC4 soap_get_PointerToPointerTons1__MessageEvent(struct soap *soap, ns1__MessageEvent ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__MessageEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__MessageEvent *** SOAP_FMAC4 soap_in_PointerToPointerTons1__MessageEvent(struct soap *soap, const char *tag, ns1__MessageEvent ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MessageEvent ***)soap_malloc(soap, sizeof(ns1__MessageEvent **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__MessageEvent(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__MessageEvent ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__MessageEvent, sizeof(ns1__MessageEvent *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MessageEvent(struct soap *soap, ns1__MessageEvent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MessageEvent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MessageEvent(struct soap *soap, ns1__MessageEvent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MessageEvent);
	if (soap_out_PointerTons1__MessageEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MessageEvent(struct soap *soap, const char *tag, int id, ns1__MessageEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MessageEvent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MessageEvent ** SOAP_FMAC4 soap_get_PointerTons1__MessageEvent(struct soap *soap, ns1__MessageEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MessageEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__MessageEvent ** SOAP_FMAC4 soap_in_PointerTons1__MessageEvent(struct soap *soap, const char *tag, ns1__MessageEvent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MessageEvent **)soap_malloc(soap, sizeof(ns1__MessageEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MessageEvent *)soap_instantiate_ns1__MessageEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__MessageEvent ** p = (ns1__MessageEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MessageEvent, sizeof(ns1__MessageEvent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__DeviceState(struct soap *soap, ns1__DeviceState **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__DeviceState))
		soap_serialize_PointerTons1__DeviceState(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__DeviceState(struct soap *soap, ns1__DeviceState **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__DeviceState);
	if (soap_out_PointerToPointerTons1__DeviceState(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__DeviceState(struct soap *soap, const char *tag, int id, ns1__DeviceState **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__DeviceState);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__DeviceState(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__DeviceState *** SOAP_FMAC4 soap_get_PointerToPointerTons1__DeviceState(struct soap *soap, ns1__DeviceState ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__DeviceState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__DeviceState *** SOAP_FMAC4 soap_in_PointerToPointerTons1__DeviceState(struct soap *soap, const char *tag, ns1__DeviceState ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DeviceState ***)soap_malloc(soap, sizeof(ns1__DeviceState **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__DeviceState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__DeviceState ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__DeviceState, sizeof(ns1__DeviceState *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__DeviceState(struct soap *soap, ns1__DeviceState *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__DeviceState))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__DeviceState(struct soap *soap, ns1__DeviceState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__DeviceState);
	if (soap_out_PointerTons1__DeviceState(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__DeviceState(struct soap *soap, const char *tag, int id, ns1__DeviceState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__DeviceState);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__DeviceState ** SOAP_FMAC4 soap_get_PointerTons1__DeviceState(struct soap *soap, ns1__DeviceState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__DeviceState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__DeviceState ** SOAP_FMAC4 soap_in_PointerTons1__DeviceState(struct soap *soap, const char *tag, ns1__DeviceState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__DeviceState **)soap_malloc(soap, sizeof(ns1__DeviceState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__DeviceState *)soap_instantiate_ns1__DeviceState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__DeviceState ** p = (ns1__DeviceState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__DeviceState, sizeof(ns1__DeviceState), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfString(struct soap *soap, ArrayOfString *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfString(struct soap *soap, ArrayOfString *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfString);
	if (soap_out_PointerToArrayOfString(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfString(struct soap *soap, const char *tag, int id, ArrayOfString *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfString);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfString ** SOAP_FMAC4 soap_get_PointerToArrayOfString(struct soap *soap, ArrayOfString **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfString(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ArrayOfString ** SOAP_FMAC4 soap_in_PointerToArrayOfString(struct soap *soap, const char *tag, ArrayOfString **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfString **)soap_malloc(soap, sizeof(ArrayOfString *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfString *)soap_instantiate_ArrayOfString(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfString ** p = (ArrayOfString **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfString, sizeof(ArrayOfString), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

/* End of soapC.cpp */
